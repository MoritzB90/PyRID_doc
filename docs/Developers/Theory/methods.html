<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Theory and Methods &mdash; PyRID 15.06.2022 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/my_theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/design-tabs.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Results and validation" href="results.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PyRID
            <img src="../../_static/PyRID_Logo_Render2_cropped.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Users</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Users/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Users/User_Guide/Contents.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Users/Examples/Contents.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Users/Advanced/Contents.html">Advanced</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Developer%20API/Contents.html">Developer API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Contents.html">Theory</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Theory and Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rigid-bead-molecules">Rigid bead molecules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#propagation-of-translational-and-angular-motion">Propagation of translational and angular motion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mobility-tensor-for-rigid-bead-models">Mobility tensor for rigid bead models</a></li>
<li class="toctree-l4"><a class="reference internal" href="#center-of-diffusion">Center of Diffusion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#compartments">Compartments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#triangulated-meshes">Triangulated meshes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volume-molecules">Volume molecules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surface-molecules">Surface molecules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fixed-concentration-boundary-conditions">Fixed concentration boundary conditions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reactions">Reactions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unimolecular-reactions">Unimolecular reactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bi-molecular-reactions">Bi-molecular reactions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#potentials">Potentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#weak-piecewise-harmonic-potential">Weak piecewise harmonic potential</a></li>
<li class="toctree-l4"><a class="reference internal" href="#harmonic-repulsion-potential">Harmonic repulsion potential</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuous-square-well-csw-potential">Continuous Square-Well (CSW) potential</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pseudo-hard-sphere-phs-potential">Pseudo Hard Sphere (PHS) potential</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#observables">Observables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#radial-distribution-function">Radial distribution function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressure">Pressure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#berendsen-barostat">Berendsen barostat</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-of-molecules">Distribution of molecules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id58">Volume molecules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surface-molecules-1">Surface molecules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#fast-algorithms-for-brownian-dynamics-of-reacting-and-interacting-particles">Fast algorithms for Brownian dynamics of reacting and interacting particles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-arrays-in-pyrid">Dynamic arrays in PyRID</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#polydispersity">Polydispersity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-loop">Simulation loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="results.html">Results and validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="discussion.html">Discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Validation/Contents.html">Validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../References.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/MoritzB90/PyRID">GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/">PyPI</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.youtube.com/channel/UC4o41QLwsfeh0g981MZPl7w">Youtube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">license</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyRID</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="Contents.html">Theory</a> &raquo;</li>
      <li>Theory and Methods</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Developers/Theory/methods.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="theory-and-methods">
<span id="sec-methods-pyrid"></span><h1>Theory and Methods<a class="headerlink" href="#theory-and-methods" title="Permalink to this heading"></a></h1>
<p>In this section, I will introduce and discuss the main methods used in
PyRID. I start in section 1.1 <a class="reference internal" href="#sec-rb-mol"><span class="std std-ref">Rigid bead molecules</span></a> by introducing the
scheme by which bead molecules are represented. Followed by the
derivation of an algorithm for the propagation of translational and
predominantly rotational diffusion. The rotational and translational
mobility tensors dictate the translational and rotational motion of
anisotropic rigid bodies. Therefore, in section
1.3 <a class="reference internal" href="#sec-mobility-tensors"><span class="std std-ref">Mobility tensor for rigid bead models</span></a> I outline the calculation of the
mobility tensors based on a modified Oseen tensor
<span id="id1">[<a class="reference internal" href="../../References.html#id8" title="Beatriz Carrasco and José Garc\'ıa de la Torre. Hydrodynamic properties of rigid particles: comparison of different modeling and computational procedures. Biophysical Journal, 76(6):3044–3057, jun 1999. doi:10.1016/s0006-3495(99)77457-6.">2</a>]</span>. One of the main features of PyRID
that distinguishes it from other molecular dynamics tools such as
LAMMPS, Gromacs and HooMD is the ability to simulate arbitrary
unimolecular and bimolecular reactions using stochastic simulation
algorithms. In section 1.7 <a class="reference internal" href="#sec-reactions"><span class="std std-ref">Reactions</span></a> I describe how these
reactions are evaluated in PyRID. Another notable feature of PyRID is
its ability to restrict the motion of molecules to complex compartment
geometries represented by triangulated meshes. Section
1.5 <a class="reference internal" href="#sec-compartments"><span class="std std-ref">Compartments</span></a> gives a brief overview of how compartment
collisions and surface diffusion are handled. The remainder of this
chapter discusses some additional methods and algorithms: Distribution
of molecules in mesh volumes and on surfaces, fast data structures for
molecular dynamics simulations, fixed concentration boundary conditions
and barostat/pressure calculation for rigid bead model systems.</p>
<section id="rigid-bead-molecules">
<span id="sec-rb-mol"></span><h2>Rigid bead molecules<a class="headerlink" href="#rigid-bead-molecules" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs" title="pyrid.molecules.rigidbody_util.RBs"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/particles_util.html#pyrid.molecules.particles_util.Particles" title="pyrid.molecules.particles_util.Particles"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.particles_util.Particles</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.evenly_on_sphere" title="pyrid.system.distribute_surface_util.evenly_on_sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.evenly_on_sphere</span></code></a></p>
</div>
</details><p>Proteins and other molecules are not point like particles. Especially
the interactions between proteins are not accurately described by
isotropic energy potentials. Instead, the physical properties of
bio-molecular systems emerge from an-isotropic multivalent interactions
<span id="id2">[<a class="reference internal" href="../../References.html#id2" title="Jorge R. Espinosa, Adiran Garaizar, Carlos Vega, Daan Frenkel, and Rosana Collepardo-Guevara. Breakdown of the law of rectilinear diameter and related surprises in the liquid-vapor coexistence in systems of patchy particles. The Journal of Chemical Physics, 150(22):224510, jun 2019. doi:10.1063/1.5098551.">30</a>, <a class="reference internal" href="../../References.html#id62" title="Gregory L. Dignon, Wenwei Zheng, Young C. Kim, Robert B. Best, and Jeetain Mittal. Sequence determinants of protein phase behavior from a coarse-grained model. PLOS Computational Biology, 14(1):e1005941, jan 2018. doi:10.1371/journal.pcbi.1005941.">72</a>]</span>. Protein-protein
interaction can be accurately simulated in all-atom molecular dynamics
simulations. However, even modern computers and algorithms are not
efficient enough to simulate systems with more than a few molecules on
time scales relevant for processes such as protein assembly and LLPS.
Therefore, coarse graining methods are needed
<span id="id3">[<a class="reference internal" href="../../References.html#id53" title="Valentina Tozzini. Coarse-grained models for proteins. Current Opinion in Structural Biology, 15(2):144–150, apr 2005. doi:10.1016/j.sbi.2005.02.005.">73</a>]</span>. Rigid bead models are a method of
minimal coarse graining that have some important benefits. Strong and
short ranged interactions between atoms are replaced by a rigid bead
topology. This allows for integration time steps several orders larger
than in all-atom simulations when atoms within the molecule are held
together by an energy potential. Usually, the beads of a rigid bead
model do not represent single atoms but pattern the geometry of the
molecule of interest <span id="id4">[<a class="reference internal" href="../../References.html#id63" title="J Garcia de la Torre. Building hydrodynamic bead–shell models for rigid bioparticles of arbitrary shape. Biophysical Chemistry, 94(3):265–274, dec 2001. doi:10.1016/s0301-4622(01)00244-7.">1</a>]</span>, significantly
reducing the overall number of particles that need to be simulated. In
addition, experimentally or theoretically estimated diffusion tensors
can be used to accurately describe the diffusive motion of molecules.
Importantly, multivalent protein-protein interactions can be described
by patches located on the bead model surface. On the downside, the
properties of coarse grained model systems strongly depend on the choice
of interaction potentials and other model parameters. The estimation of
these model parameters is fairly involved and is out of the scope of
this work.</p>
<p>The position of each bead i of molecule j can be characterized by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{R}_i(t) = \boldsymbol{R}_{i}^{local}(t) + \boldsymbol{R}_{j}^{O}(t)\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{R}_{i}^{local}(t) = \boldsymbol{A}_j(t) \cdot \boldsymbol{X}_{i}^{local} .\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{X}_{i}^{local}\)</span> are the coordinates of bead i in
the local reference frame, and <span class="math notranslate nohighlight">\(\boldsymbol{A}(t)\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{R}_{j}^{O}(t)\)</span> are the rotation matrix and center of
diffusion of molecule j in the lab reference frame respectively. The
center of diffusion propagates in response to external forces
<span class="math notranslate nohighlight">\(\boldsymbol{F}(t)\)</span> exerted, e.g., by particle-particle
interactions or an external force field, and due to hydrodynamic
interactions and collisions of the beads with solvent molecules
(Brownian motion). Thereby, the total force <span class="math notranslate nohighlight">\(\boldsymbol{F}(t)\)</span>
acting on the molecules’ center of diffusion is the sum of all forces
<span class="math notranslate nohighlight">\(\boldsymbol{f}_i(t)\)</span> acting on the individual beads:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{F}(t) = \sum_{i = 1}^{N_{beads}}. \boldsymbol{f}_i(t),\]</div>
<p>where <span class="math notranslate nohighlight">\(N_{beads}\)</span> is the total number of beads contained in the
molecule.</p>
<section id="propagation-of-translational-and-angular-motion">
<span id="sec-propagators"></span><h3>Propagation of translational and angular motion<a class="headerlink" href="#propagation-of-translational-and-angular-motion" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_B" title="pyrid.molecules.rigidbody_util.RBs.update_B"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_B</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_dX" title="pyrid.molecules.rigidbody_util.RBs.update_dX"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_dX</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_dq" title="pyrid.molecules.rigidbody_util.RBs.update_dq"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_dq</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_force_torque" title="pyrid.molecules.rigidbody_util.RBs.update_force_torque"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_force_torque</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat" title="pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_orientation_quat" title="pyrid.molecules.rigidbody_util.RBs.update_orientation_quat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_orientation_quat</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.set_orientation_quat" title="pyrid.molecules.rigidbody_util.RBs.set_orientation_quat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.set_orientation_quat</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_particle_pos" title="pyrid.molecules.rigidbody_util.RBs.update_particle_pos"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_particle_pos</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_particle_pos_2D" title="pyrid.molecules.rigidbody_util.RBs.update_particle_pos_2D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_particle_pos_2D</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.update_topology" title="pyrid.molecules.rigidbody_util.RBs.update_topology"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.update_topology</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.sqrt_matrix" title="pyrid.math.transform_util.sqrt_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.sqrt_matrix</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/update_pos.html#pyrid.system.update_pos.update_rb" title="pyrid.system.update_pos.update_rb"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.update_pos.update_rb</span></code></a>
<a class="reference internal" href="../Developer%20API/system/update_pos.html#pyrid.system.update_pos.update_rb_compartments" title="pyrid.system.update_pos.update_rb_compartments"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.update_pos.update_rb_compartments</span></code></a></p>
</div>
</details><p>The motion of an isolated rigid bead molecule j in solution can be
described in terms of the Langevin equation for translational and
rotational motion. Note that we are always considering isolated
molecules in dispersion and do not account for the hydrodynamic
interaction between molecules as this is computationally very expensive
(<span class="math notranslate nohighlight">\(O(N^2)-O(N^3)\)</span>) <span id="id5">[<a class="reference internal" href="../../References.html#id49" title="Tihamér Geyer and Uwe Winter. An o(n2) approximation for hydrodynamic interactions in brownian dynamics simulations. The Journal of Chemical Physics, 130(11):114905, mar 2009. doi:10.1063/1.3089668.">74</a>, <a class="reference internal" href="../../References.html#id47" title="Maciej Długosz and Joanna Trylska. Diffusion in crowded biological environments: applications of brownian dynamics. BMC Biophysics, mar 2011. doi:10.1186/2046-1682-4-3.">75</a>]</span>. In
the most general case the Langevin equation for translational and
rotational motion reads
<span id="id6">[<a class="reference internal" href="../../References.html#id43" title="Donald L. Ermak and J. A. McCammon. Brownian dynamics with hydrodynamic interactions. The Journal of Chemical Physics, 69(4):1352–1360, aug 1978. doi:10.1063/1.436761.">76</a>, <a class="reference internal" href="../../References.html#id46" title="Eric Dickinson, Stuart A. Allison, and J. Andrew McCammon. Brownian dynamics with rotation–translation coupling. J. Chem. Soc., Faraday Trans. 2, 81(4):591–601, 1985. doi:10.1039/f29858100591.">77</a>, <a class="reference internal" href="../../References.html#id45" title="R B Jones and P N Pusey. Dynamics of suspended colloidal spheres. Annual Review of Physical Chemistry, 42(1):137–169, oct 1991. doi:10.1146/annurev.pc.42.100191.001033.">78</a>]</span>:</p>
<div class="math notranslate nohighlight">
\[m \frac{d^2\boldsymbol{r}_j(t)}{dt^2} = \boldsymbol{F}_j - \Big(\boldsymbol{\Xi}^{tt} \frac{d\boldsymbol{r}_j}{dt} + \boldsymbol{\Xi}^{tr} \frac{d\boldsymbol{\phi}_j}{dt}\Big) + \boldsymbol{R}^t\]</div>
<div class="math notranslate nohighlight">
\[\frac{d}{dt} \Big( I \frac{d \boldsymbol{\phi}_j(t)}{dt} \Big) = \boldsymbol{T}_j - \Big(\boldsymbol{\Xi}^{rr} \frac{d\boldsymbol{\phi}_j}{dt} + \boldsymbol{\Xi}^{rt} \frac{d\boldsymbol{r}_j}{dt}\Big) + \boldsymbol{R}^r,\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{r}_j(t)\)</span> is the position of the molecule center
and <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_j(t)\)</span> the rotation angle.
<span class="math notranslate nohighlight">\(\boldsymbol{F}_j\)</span> is the total force exerted on molecule j and
<span class="math notranslate nohighlight">\(\boldsymbol{T}_j\)</span> is the torque. <span class="math notranslate nohighlight">\(\boldsymbol{R}^t\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{R}^r\)</span> describe the random, erratic movement of the
molecule due to collisions with the solvent molecules where</p>
<div class="math notranslate nohighlight">
\[\langle \boldsymbol{R}^a(t)\rangle = 0\]</div>
<div class="math notranslate nohighlight">
\[\langle \boldsymbol{R}^a(t) \boldsymbol{R}^b(t')\rangle = 2 k_B T \boldsymbol{\Xi}_{ij}^{ab} \delta(t-t'),\]</div>
<p>with <span class="math notranslate nohighlight">\(a,b \in \{t,r\}\)</span>. Here,
<span class="math notranslate nohighlight">\(\boldsymbol{\Xi}^{tt}, \boldsymbol{\Xi}^{rr}, \boldsymbol{\Xi}^{tr}, \boldsymbol{\Xi}^{rt}\)</span>
are the translational, rotational and translation-rotation coupling
friction tensors of the rigid body in the lab frame. Also,
<span class="math notranslate nohighlight">\(\boldsymbol{\Xi}^{ab} = k_B T (\boldsymbol{D}^{-1})^{ab}\)</span>
(Einstein relation). Due to the translation-rotation coupling, the
equations for rotation and translation are not independent. For low-mass
particles, such as molecules, and for long enough time intervals, the
acceleration of the molecules can be neglected in the description of the
diffusion process. As such it is convenient to describe the motion of
molecules by overdamped Langevin dynamics also called Brownian motion
where
<span class="math notranslate nohighlight">\(I \frac{d^2 \phi_j(t)}{dt^2} = m \frac{d^2 x_j(t)}{dt^2} = 0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{d\boldsymbol{r}_j(t)}{dt} = \boldsymbol{M}_{j}^{tt} \boldsymbol{F}_j + \boldsymbol{M}_{j}^{tr} \boldsymbol{T}_j + \boldsymbol{S}^t\]</div>
<div class="math notranslate nohighlight">
\[\frac{d \boldsymbol{\phi}_j(t)}{dt} = \boldsymbol{M}_{j}^{rr} \boldsymbol{T}_j + \boldsymbol{M}_{j}^{rt} \boldsymbol{F}_j + \boldsymbol{S}^r.\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\langle \boldsymbol{S}^a(t)\rangle = 0\]</div>
<div class="math notranslate nohighlight">
\[\langle \boldsymbol{S}^a(t) \boldsymbol{S}^b(t')\rangle = 2 k_B T \boldsymbol{M}_{ij}^{ab} \delta(t-t'),\]</div>
<p>where
<span class="math notranslate nohighlight">\(\boldsymbol{M}^{tt}, \boldsymbol{M}^{rr}, \boldsymbol{M}^{tr}, \boldsymbol{M}^{rt}\)</span>
are the translational, rotational and translation-rotation coupling
mobility tensors of the rigid body in the lab frame and
<span class="math notranslate nohighlight">\(\boldsymbol{M}^{ab} = \frac{\boldsymbol{D}^{ab}}{k_B T}\)</span>. Also
<span class="math notranslate nohighlight">\(\boldsymbol{M}^{rt} = \boldsymbol{M}^{tr,T}\)</span>. In most cases, the
effect of the translation-rotation coupling on the molecular dynamics is
negligible. However, translation-rotation coupling increases the
complexity of the propagation algorithm for the translation and rotation
vectors. Therefore, in the following, we will consider translation and
rotation as being independent. In this case, the propagator for the
Cartesian coordinates as well as the orientation angle can be formulated
as <span id="id7">[<a class="reference internal" href="../../References.html#id20" title="Ioana M. Ilie, Wim J. Briels, and Wouter K. den Otter. An elementary singularity-free rotational brownian dynamics algorithm for anisotropic particles. The Journal of Chemical Physics, 142(11):114103, mar 2015. doi:10.1063/1.4914322.">13</a>]</span></p>
<div class="math notranslate nohighlight" id="equation-eq-drdt">
<span class="eqno">(32)<a class="headerlink" href="#equation-eq-drdt" title="Permalink to this equation"></a></span>\[\boldsymbol{r}_j(t) = \boldsymbol{r}_j(t-\Delta t) + \boldsymbol{A}_j \boldsymbol{M}_{j}^{tt,b} \boldsymbol{A}_j^T \boldsymbol{F}_j \Delta t + \boldsymbol{A}_j \sqrt{2 \boldsymbol{M}_{j}^{tt,b} k_B T}\, \boldsymbol{W}^t(\Delta t)\]</div>
<div class="math notranslate nohighlight" id="equation-eq-dphidt">
<span class="eqno">(33)<a class="headerlink" href="#equation-eq-dphidt" title="Permalink to this equation"></a></span>\[\boldsymbol{\phi}_j(t) = \boldsymbol{\phi}_j(t-\Delta t) + \boldsymbol{A}_j \boldsymbol{M}_{j}^{rr,b} \boldsymbol{A}_j^T \boldsymbol{T}_j \Delta t + \boldsymbol{A}_j \sqrt{2 \boldsymbol{M}_{j}^{rr,b} k_B T}\, \boldsymbol{W}^r(\Delta t).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\boldsymbol{W}(\Delta t)\)</span> is a 3-dimensional Wiener
process, i.e.
<span class="math notranslate nohighlight">\(\boldsymbol{W}(t+\Delta t) - \boldsymbol{W}(t) \sim \mathcal{N}(0, \Delta t)\)</span>,
which can be argued from the central limit theorem and the assumption
that the forces of the solvent molecules act with equal probability from
all directions. The superscript <span class="math notranslate nohighlight">\(b\)</span> indicates that the mobility
tensors <span class="math notranslate nohighlight">\(\boldsymbol{M}^{ab,b}\)</span> are given in terms of the
body/local frame of the molecule, which is much more convenient when we
talk about the propagation algorithm. In this context,
<span class="math notranslate nohighlight">\(\boldsymbol{A}_j\)</span> is the rotation matrix of molecule j. One
problem with the rotational equation of motion is that several issues
arise depending on how rotations are represented. Propagating the
rotation in terms of Euler angles, e.g., will result in numerical drift
and singularities <span id="id8">[<a class="reference internal" href="../../References.html#id30" title="David Baraff. Physically based modeling: rigid body simulation. SIGGRAPH Course Notes, 2001. doi:10.1145/97880.97881.">79</a>, <a class="reference internal" href="../../References.html#id21" title="Ioana M. Ilie, Wouter K. den Otter, and Wim J. Briels. A coarse grained protein model with internal degrees of freedom. application to $\less $i$\greater $$\upalpha $$\less $/i$\greater $-synuclein aggregation. The Journal of Chemical Physics, 144(8):085103, feb 2016. doi:10.1063/1.4942115.">80</a>]</span>. Therefore,
especially in computer graphics, it is standard to represent rotations
in unit quaternions, which is much more stable and has fewer issues in
general. An algorithm for the rotation propagator based on quaternions
can, for example, be found in <span id="id9">[<a class="reference internal" href="../../References.html#id20" title="Ioana M. Ilie, Wim J. Briels, and Wouter K. den Otter. An elementary singularity-free rotational brownian dynamics algorithm for anisotropic particles. The Journal of Chemical Physics, 142(11):114103, mar 2015. doi:10.1063/1.4914322.">13</a>]</span>. In the
following, I will introduce a more concise derivation of the very same
algorithm.</p>
<section id="quaternion-propagator">
<h4>Quaternion propagator<a class="headerlink" href="#quaternion-propagator" title="Permalink to this heading"></a></h4>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.rot_quaternion" title="pyrid.math.transform_util.rot_quaternion"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.rot_quaternion</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.quat_mult" title="pyrid.math.transform_util.quat_mult"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.quat_mult</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.quaternion_plane_to_plane" title="pyrid.math.transform_util.quaternion_plane_to_plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.quaternion_plane_to_plane</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.quaternion_random_axis_rot" title="pyrid.math.transform_util.quaternion_random_axis_rot"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.quaternion_random_axis_rot</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.quaternion_to_plane" title="pyrid.math.transform_util.quaternion_to_plane"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.quaternion_to_plane</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.rot_quaternion" title="pyrid.math.transform_util.rot_quaternion"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.rot_quaternion</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.random_quaternion" title="pyrid.system.distribute_vol_util.random_quaternion"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.random_quaternion</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.random_quaternion_tuple" title="pyrid.system.distribute_vol_util.random_quaternion_tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.random_quaternion_tuple</span></code></a></p>
</div>
</details><p>The orientation/rotation of the molecule can be described by a unit
quaternion <span class="math notranslate nohighlight">\(\boldsymbol{q} = q_0 + i\,q_1 + j\,q_2 + k\, q_3\)</span>
where <span class="math notranslate nohighlight">\(\boldsymbol{q}^2 = \sum_{i=0}^3 q_i^2 = 1\)</span>. Quaternions can
be thought of as an extension to complex numbers and were introduced in
1844 by Sir William Rowan Hamilton <span id="id10">[<a class="reference internal" href="../../References.html#id117" title="William Rowan Hamilton. II. $\less $i$\greater $on quaternions$\mathsemicolon $ or on a new system of imaginaries in algebra$\less $/i$\greater $. The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science, 25(163):10–13, jul 1844. doi:10.1080/14786444408644923.">81</a>]</span>.
The rotation quaternion <span class="math notranslate nohighlight">\(\boldsymbol{q}(t)\)</span> propagates in response
to the torque
<span class="math notranslate nohighlight">\(\boldsymbol{T}_i(t) = \boldsymbol{F}_i(t) \times \boldsymbol{r}_{ij}\)</span>
exerted by the external forces, where <span class="math notranslate nohighlight">\(\boldsymbol{r}_{ij}\)</span> is the
distance vector between bead i and the center of diffusion of molecule
j. The rotation matrix can be represented in terms of rotation
quaternions by <span id="id11">[<a class="reference internal" href="../../References.html#id30" title="David Baraff. Physically based modeling: rigid body simulation. SIGGRAPH Course Notes, 2001. doi:10.1145/97880.97881.">79</a>]</span> (<a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat" title="pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.calc_orientation_quat</span></code></a>):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}\boldsymbol{A}
    =
    \begin{pmatrix}
        1-2(q_2^2+q_3^2) &amp; 2(q_1 q_2-q_0 q_3) &amp; 2(q_1 q_3+q_0 q_2) \\
        2(q_1 q_2+q_0 q_3) &amp; 1-2(q_1^2+q_3^2) &amp; 2(q_2 q_3-q_0 q_1) \\
    2(q_1 q_3-q_0 q_2) &amp; 2(q_2 q_3+q_0 q_1) &amp; 1-2(q_1^2+q_2^2) \\
    \end{pmatrix},
    \end{split}\end{split}\]</div>
<p>The goal is to derive a propagator for the rotation quaternion. A
well-established connection between the angular velocity and the unit
quaternion velocity is <span id="id12">[<a class="reference internal" href="../../References.html#id30" title="David Baraff. Physically based modeling: rigid body simulation. SIGGRAPH Course Notes, 2001. doi:10.1145/97880.97881.">79</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-dg-dphi">
<span class="eqno">(34)<a class="headerlink" href="#equation-eq-dg-dphi" title="Permalink to this equation"></a></span>\[\frac{d\boldsymbol{q}}{dt} = \frac{1}{2} \frac{d\boldsymbol{\phi}}{dt} \boldsymbol{q} = \boldsymbol{B} \frac{d\boldsymbol{\phi}}{dt}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}\boldsymbol{B}
    = \frac{1}{2}
    \begin{pmatrix}
        -q_1 &amp; -q_2 &amp; -q_3 \\
        q_0 &amp; q_3 &amp; -q_2 \\
        -q_3 &amp; q_0 &amp; q_1 \\
        q_2 &amp; -q_1 &amp; q_0 \\
    \end{pmatrix}.
    \end{split}\end{split}\]</div>
<p>Inserting <a class="reference internal" href="#equation-eq-dphidt">(33)</a> into <a class="reference internal" href="#equation-eq-dg-dphi">(34)</a>, we get:</p>
<div class="math notranslate nohighlight" id="equation-eq-dqdt">
<span class="eqno">(35)<a class="headerlink" href="#equation-eq-dqdt" title="Permalink to this equation"></a></span>\[\boldsymbol{q}_j(t) = \boldsymbol{q}_j(t-\Delta t) + \boldsymbol{B}_j\boldsymbol{A}_j \boldsymbol{M}_{j}^{rr,b} \boldsymbol{A}_j^T \boldsymbol{T}_j \Delta t + \boldsymbol{B}_j \boldsymbol{A}_j \sqrt{2 \boldsymbol{M}_{j}^{rr,b} k_B T}\, \boldsymbol{W}^r(\Delta t).\]</div>
<p>The factor <span class="math notranslate nohighlight">\(\boldsymbol{B}\boldsymbol{A}\)</span> can, however, be
simplified:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
    \boldsymbol{B}\boldsymbol{A}
    = &amp; \frac{1}{2}
    \begin{pmatrix}
        -q_1 &amp; -q_2 &amp; -q_3 \\
        q_0 &amp; q_3 &amp; -q_2 \\
        -q_3 &amp; q_0 &amp; q_1 \\
        q_2 &amp; -q_1 &amp; q_0 \\
    \end{pmatrix}
    \begin{pmatrix}
        1-2(q_2^2+q_3^2) &amp; 2(q_1 q_2-q_0 q_3) &amp; 2(q_1 q_3+q_0 q_2) \\
        2(q_1 q_2+q_0 q_3) &amp; 1-2(q_1^2+q_3^2) &amp; 2(q_2 q_3-q_0 q_1) \\
    2(q_1 q_3-q_0 q_2) &amp; 2(q_2 q_3+q_0 q_1) &amp; 1-2(q_1^2+q_2^2) \\
    \end{pmatrix}\\
    = &amp; \frac{1}{2}
    \begin{pmatrix}
       -q_1 &amp; -q_2 &amp; -q_3 \\
        q_0 &amp; q_3 (1-2 q^2 ) &amp; q_2 (2 q^2 -1) \\
        q_3 (2 q^2 -1) &amp; q_0 &amp; q1 (1-2 q^2 ) \\
        q_2 (1-2 q^2) &amp; q_1 (2 q^2-1) &amp; q_0 \\
    \end{pmatrix} \\
    = &amp; \frac{1}{2}
    \begin{pmatrix}
       -q_1 &amp; -q_2 &amp; -q_3 \\
        q_0 &amp; -q_3 &amp; q_2 \\
        q_3 &amp; q_0 &amp; -q_1 \\
        -q_2 &amp; q_1 &amp; q_0 \\
    \end{pmatrix},
    \end{split}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(q^2 = q_0^2+q_1^2+q_2^2+q_3^2 = 1\)</span>. For the quaternion to
accurately represent the rotation, we need to ensure that it keeps its
unit length. However, due to the finite time step in simulations, the
quaternion will diverge from unit length over time. Thus, it is
necessary to frequently re-normalize the quaternion.
<span id="id13">Ilie <em>et al.</em> [<a class="reference internal" href="../../References.html#id20" title="Ioana M. Ilie, Wim J. Briels, and Wouter K. den Otter. An elementary singularity-free rotational brownian dynamics algorithm for anisotropic particles. The Journal of Chemical Physics, 142(11):114103, mar 2015. doi:10.1063/1.4914322.">13</a>]</span> point out that re-normalization will
introduce a bias by changing the sampled phase space distribution.
Thereby, it is more appropriate to introduce a constraint force using
the method of undetermined Lagrange multipliers as is used in molecular
dynamics algorithms such as SHAKE. However, for integration time steps
used in practice, I found the error introduced by re-normalization to be
negligible. Validation of the above algorithms are presented in section
<a class="reference internal" href="results.html#sec-val-diff"><span class="std std-ref">Anisotropic diffusion</span></a>.</p>
</section>
</section>
<section id="mobility-tensor-for-rigid-bead-models">
<span id="sec-mobility-tensors"></span><h3>Mobility tensor for rigid bead models<a class="headerlink" href="#mobility-tensor-for-rigid-bead-models" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#module-pyrid.molecules.hydro_util" title="pyrid.molecules.hydro_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.A" title="pyrid.molecules.hydro_util.A"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.A</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.P" title="pyrid.molecules.hydro_util.P"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.P</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.calc_D" title="pyrid.molecules.hydro_util.calc_D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.calc_D</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.calc_Xi" title="pyrid.molecules.hydro_util.calc_Xi"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.calc_Xi</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.calc_mu" title="pyrid.molecules.hydro_util.calc_mu"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.calc_mu</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.calc_zeta" title="pyrid.molecules.hydro_util.calc_zeta"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.calc_zeta</span></code></a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.diffusion_tensor</span></code>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.diffusion_tensor_off_center" title="pyrid.molecules.hydro_util.diffusion_tensor_off_center"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.diffusion_tensor_off_center</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.levi_civita" title="pyrid.molecules.hydro_util.levi_civita"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.levi_civita</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.supermatrix_inverse" title="pyrid.molecules.hydro_util.supermatrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.supermatrix_inverse</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.transform_reverse_supermatrix" title="pyrid.molecules.hydro_util.transform_reverse_supermatrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.transform_reverse_supermatrix</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.transform_supermatrix" title="pyrid.molecules.hydro_util.transform_supermatrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.transform_supermatrix</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.set_diffusion_tensor" title="pyrid.system.system_util.System.set_diffusion_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.set_diffusion_tensor</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.valid_mobility_tensor_test" title="pyrid.math.transform_util.valid_mobility_tensor_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.valid_mobility_tensor_test</span></code></a></p>
</div>
</details><p>In order simulate the motion of molecules with the algorithms introduced
above, we need to calculate the molecule’s diffusion tensor. Diffusion
tensors have also been estimated experimentally
<span id="id14">[<a class="reference internal" href="../../References.html#id22" title="Marc Niethammer, Raul San Jose Estepar, Sylvain Bouix, Martha Shenton, and Carl-Fredrik Westin. On diffusion tensor estimation. In 2006 International Conference of the IEEE Engineering in Medicine and Biology Society. IEEE, aug 2006. doi:10.1109/iembs.2006.259826.">14</a>]</span> or using molecular dynamics
simulations <span id="id15">[<a class="reference internal" href="../../References.html#id52" title="Guillaume Chevrot, Konrad Hinsen, and Gerald R. Kneller. Model-free simulation approach to molecular diffusion tensors. The Journal of Chemical Physics, 139(15):154110, oct 2013. doi:10.1063/1.4823996.">82</a>]</span>. However, for many
proteins, the diffusion tensor is unknown. Therefore, it would often be
more convenient to calculate the diffusion tensor directly from the
coarse-grained representation of a molecule in terms of the rigid bead
model. Pioneering work in this direction has been done by
<span id="id16">Bloomfield <em>et al.</em> [<a class="reference internal" href="../../References.html#id31" title="V. Bloomfield, W. O. Dalton, and K. E. Van Holde. Frictional coefficients of multisubunit structures. i. theory. Biopolymers, 5(2):135–148, feb 1967. doi:10.1002/bip.1967.360050202.">83</a>]</span> and <span id="id17">Torre and Bloomfield [<a class="reference internal" href="../../References.html#id13" title="Jose Garcia De La Torre and Victor A. Bloomfield. Hydrodynamic properties of macromolecular complexes. i. translation. Biopolymers, 16(8):1747–1763, aug 1977. doi:10.1002/bip.1977.360160811.">18</a>]</span>.
In the following I will only present the main results that are needed
for the calculation of the rigid bead model diffusion tensor. For the
interested reader, a more in depth introduction can be found in
<a class="reference internal" href="appendix.html#sec-appendix-a"><span class="std std-ref">Appendix A</span></a> Appendix A.</p>
<p>In general, the mobility and/or diffusion tensor of an anisotropic rigid
body can be calculated from the inverse of the rigid body’s friction
supermatrix <span id="id18">[<a class="reference internal" href="../../References.html#id8" title="Beatriz Carrasco and José Garc\'ıa de la Torre. Hydrodynamic properties of rigid particles: comparison of different modeling and computational procedures. Biophysical Journal, 76(6):3044–3057, jun 1999. doi:10.1016/s0006-3495(99)77457-6.">2</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-mobility-supermatrix">
<span class="eqno">(36)<a class="headerlink" href="#equation-eq-mobility-supermatrix" title="Permalink to this equation"></a></span>\[\begin{split}\begin{pmatrix}
\boldsymbol{M}^{tt} &amp; \boldsymbol{M}^{tr,T} \\
\boldsymbol{M}^{rt} &amp; \boldsymbol{M}^{rr} \\
\end{pmatrix}
=
\frac{1}{k_B T}
\begin{pmatrix}
\boldsymbol{D}^{tt} &amp; \boldsymbol{D}^{tr,T} \\
\boldsymbol{D}^{rt} &amp; \boldsymbol{D}^{rr} \\
\end{pmatrix}
=
\begin{pmatrix}
\boldsymbol{\Xi}^{tt} &amp; \boldsymbol{\Xi}^{tr,T} \\
\boldsymbol{\Xi}^{rt} &amp; \boldsymbol{\Xi}^{rr} \\
\end{pmatrix}^{-1}.\end{split}\]</div>
<p>Therefore, the main challenge lies in deriving an expression for the
translational, rotational and translation-rotation coupling tensors of
the friction super matrix
<span class="math notranslate nohighlight">\(\boldsymbol{\Xi}^{tt}, \boldsymbol{\Xi}^{rr}, \boldsymbol{\Xi}^{tr}=\boldsymbol{\Xi}^{rt,T}\)</span>.
PyRID uses a method based on a modified Oseen tensor
<span id="id19">[<a class="reference internal" href="../../References.html#id8" title="Beatriz Carrasco and José Garc\'ıa de la Torre. Hydrodynamic properties of rigid particles: comparison of different modeling and computational procedures. Biophysical Journal, 76(6):3044–3057, jun 1999. doi:10.1016/s0006-3495(99)77457-6.">2</a>, <a class="reference internal" href="../../References.html#id13" title="Jose Garcia De La Torre and Victor A. Bloomfield. Hydrodynamic properties of macromolecular complexes. i. translation. Biopolymers, 16(8):1747–1763, aug 1977. doi:10.1002/bip.1977.360160811.">18</a>]</span> to account for the
hydrodynamic interaction between the beads of a rigid bead molecule in a
first order approximation <span id="id20">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>]</span>. For a
rigid molecule consisting of <span class="math notranslate nohighlight">\(N\)</span> different beads, the friction
tensors read</p>
<div class="math notranslate nohighlight" id="equation-eq-mobility-supermatrix-rbm">
<span class="eqno">(37)<a class="headerlink" href="#equation-eq-mobility-supermatrix-rbm" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
&amp;\boldsymbol{\Xi}^{tt} = \sum_{i=1}^N \sum_{j=1}^N \boldsymbol{\xi}_{ij}^{tt} \\
&amp;\boldsymbol{\Xi}_{O}^{tr} = \sum_{i=1}^N \sum_{j=1}^N ( -\boldsymbol{\xi}_{ij}^{tt} \cdot \boldsymbol{A}_j + \boldsymbol{\xi}_{ij}^{tr} ) \\
&amp;\boldsymbol{\Xi}_{O}^{rt} = \sum_{i=1}^N \sum_{j=1}^N ( \boldsymbol{A}_j \cdot \boldsymbol{\xi}_{ij}^{tt} + \boldsymbol{\xi}_{ij}^{rt} ) \\
&amp;\boldsymbol{\Xi}_{O}^{rr} = \sum_{i=1}^N \sum_{j=1}^N ( \boldsymbol{\xi}_{ij}^{rr} - \boldsymbol{\xi}_{ij}^{rt} \cdot \boldsymbol{A}_j + \boldsymbol{A}_i \cdot \boldsymbol{\xi}_{ij}^{tr} - \boldsymbol{A}_i \cdot \boldsymbol{\xi}_{ij}^{tt} \boldsymbol{A}_j)
\end{split}.\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{A}_i
    =
    \begin{pmatrix}
    0 &amp; -z_i &amp; y_i \\
    z_i &amp; 0 &amp; -x_i \\
    -y_i &amp; x_i &amp; 0 \\
    \end{pmatrix}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\boldsymbol{r}_i = x_i e_x + y_i e_y +z_i e_z\)</span> being the
position vector of bead i in the molecule’s local reference frame.
<span class="math notranslate nohighlight">\(\boldsymbol{\xi}^{ab}, a,b \in \{t,r\}\)</span> are the translational,
rotational and translation-rotation coupling friction tensors of the
system of <span class="math notranslate nohighlight">\(N\)</span> freely diffusing beads. <span class="math notranslate nohighlight">\(\boldsymbol{\xi}\)</span>,
are calculated from the inverse of the mobility supermatrix
<span id="id21">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-mobility-supermatrix-2">
<span class="eqno">(38)<a class="headerlink" href="#equation-eq-mobility-supermatrix-2" title="Permalink to this equation"></a></span>\[\begin{split}\begin{pmatrix}
\boldsymbol{\xi}^{tt} &amp; \boldsymbol{\xi}^{tr} \\
\boldsymbol{\xi}^{rt} &amp; \boldsymbol{\xi}^{rr} \\
\end{pmatrix}
=
\begin{pmatrix}
\boldsymbol{\mu}^{tt} &amp; \boldsymbol{\mu}^{tr} \\
\boldsymbol{\mu}^{rt} &amp; \boldsymbol{\mu}^{rr} \\
\end{pmatrix}^{-1}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{\xi}^{ab}\)</span> are of dimension (3Nx3N), forming the
friction supermatrix of dimension (6N,6N). <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^{ab}\)</span>
are the (3Nx3N) dimensional elements of the mobility supermatrix. The
translational mobility tensor <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^{tt}\)</span> for a system
of different sized beads is, in first order approximation, given by
<span id="id22">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-mu-tt-methods">
<span class="eqno">(39)<a class="headerlink" href="#equation-mu-tt-methods" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
\boldsymbol{\mu}^{tt}_{ij} = &amp; \delta_{ij} (6 \pi \eta_0 \sigma_i)^{-1} \boldsymbol{I} + (1-\delta_{ij})(8 \pi \eta_0 r_{ij}^{-1})(\boldsymbol{I}+\boldsymbol{P}_{ij}) \\
&amp; + (8 \pi \eta_0 r_{ij}^{-3})(\sigma_i^2+\sigma_j^2)(\boldsymbol{I}-3 \boldsymbol{P}_{ij}),
\end{split}\end{split}\]</div>
<p>where
<span class="math notranslate nohighlight">\(\boldsymbol{P}_{ij} = \Big(\boldsymbol{I}+\frac{\boldsymbol{r} \otimes \boldsymbol{r}}{r^2} \Big)\)</span>,
<span class="math notranslate nohighlight">\(\eta_0\)</span> is the fluid viscosity and <span class="math notranslate nohighlight">\(r_{ij}\)</span> is the distance
vector between bead i and bead j. <span class="math notranslate nohighlight">\(\boldsymbol{I}\)</span> is the identity
matrix. The mobility tensor for rotation, however, not accounting for
the bead radii in the hydrodynamic interaction term, is given by
<span id="id23">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-mu-rr-methods">
<span class="eqno">(40)<a class="headerlink" href="#equation-mu-rr-methods" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
\boldsymbol{\mu}^{rr}_{ij} = &amp; \delta_{ij} (8 \pi \eta_0 \sigma_i^3)^{-1} \boldsymbol{I} \\
&amp; + (1 - \delta_{ij})(16 \pi \eta_0 r^3_{ij})^{-1} (3 \boldsymbol{P}_{ij} - \boldsymbol{I}).
\end{split}\end{split}\]</div>
<p>In this formulation, there is still a correction for the bead radii
missing. This correction consists of adding
<span class="math notranslate nohighlight">\(6 \eta_0 V_m \boldsymbol{I}\)</span> to the diagonal components of the
rotational friction tensor <span class="math notranslate nohighlight">\(\boldsymbol{\Xi}^{rr}_O\)</span>, where
<span class="math notranslate nohighlight">\(V_m\)</span> is the total volume of the rigid bead molecule
<span id="id24">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>, <a class="reference internal" href="../../References.html#id16" title="José Garc\'ıa de la Torre and Vicente Rodes. Effects from bead size and hydrodynamic interactions on the translational and rotational coefficients of macromolecular bead models. The Journal of Chemical Physics, 79(5):2454–2460, sep 1983. doi:10.1063/1.446054.">20</a>]</span>. The rotation-translation
coupling is given by <span id="id25">[<a class="reference internal" href="../../References.html#id9" title="B. Carrasco and J. Garcı\'a de la Torre. Improved hydrodynamic interaction in macromolecular bead models. The Journal of Chemical Physics, 111(10):4817–4826, sep 1999. doi:10.1063/1.479743.">16</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-mu-rt-methods">
<span class="eqno">(41)<a class="headerlink" href="#equation-mu-rt-methods" title="Permalink to this equation"></a></span>\[\boldsymbol{\mu}^{rt}_{ij} = (1-\delta_{ij}) (8 \pi \eta_0 r_{ij}^2)^{-1} \boldsymbol{\epsilon}\boldsymbol{\hat{r}}_{ij},\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon\)</span> is the Levi-Civita symbol with
<span id="id26">[<a class="reference internal" href="../../References.html#id15" title="J. Garc\'ıa de la Torre, G. del Rio Echenique, and A. Ortega. Improved calculation of rotational diffusion and intrinsic viscosity of bead models for macromolecules and nanoparticles. The Journal of Physical Chemistry B, 111(5):955–961, jan 2007. doi:10.1021/jp0647941.">19</a>]</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\epsilon \cdot \boldsymbol{r}_{ij}
    =
    \begin{pmatrix}
    0 &amp; z_{ij} &amp; -y_{ij} \\
    -z_{ij} &amp; 0 &amp; x_{ij} \\
    y_{ij} &amp; -x_{ij} &amp; 0 \\
    \end{pmatrix}.\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\boldsymbol{\mu}^{tt}, \boldsymbol{\mu}^{rr}, \boldsymbol{\mu}^{rt}\)</span>
describe the mobility of a multi-sphere system with hydrodynamic
interactions. From the above follows that we need to calculate the
inverse of a supermatrix twice, once in equation <a class="reference internal" href="#equation-eq-mobility-supermatrix">(36)</a> and once in
equation <a class="reference internal" href="#equation-eq-mobility-supermatrix-rbm">(37)</a>. A super Matrix
<span class="math notranslate nohighlight">\(\boldsymbol{M}=[[\boldsymbol{M}_1, \boldsymbol{M}_2], [\boldsymbol{M}_3, \boldsymbol{M}_4]]\)</span>
is invertible, if both the diagonal blocks, <span class="math notranslate nohighlight">\(\boldsymbol{M}_1\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{M}_4\)</span> are invertible The inverse of a (2x2)
supermatrix can be calculated by <span id="id27">[<a class="reference internal" href="../../References.html#id17" title="V. Varadarajan. Supersymmetry for Mathematicians: An Introduction. American Mathematical Society, jul 2004. doi:10.1090/cln/011.">21</a>]</span>,
<span id="id28">[<a class="reference internal" href="../../References.html#id18" title="P Deligne and J Morgan. Notes on supersymmetry following Bernstein. Quantum ﬁelds and strings; a course for mathematicians, pages 41–96. Volume 1. Amer. Math. Soc, Princeton, NJ; Providence, RI, 1996.">22</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-supermatrix-inverse">
<span class="eqno">(42)<a class="headerlink" href="#equation-supermatrix-inverse" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
&amp; \boldsymbol{T}_1 = (\boldsymbol{M}_1 - \boldsymbol{M}_2 \boldsymbol{M}_4^{-1} \boldsymbol{M}_3)^{-1} \\
&amp; \boldsymbol{T}_2 = -\boldsymbol{M}_1^{-1} \boldsymbol{M}_2 (\boldsymbol{M}_4-\boldsymbol{M}_3 \boldsymbol{M}_1^{-1} \boldsymbol{M}_2)^{-1} \\
&amp; \boldsymbol{T}_3 = -\boldsymbol{M}_4^{-1} \boldsymbol{M}_3 (\boldsymbol{M}_1-\boldsymbol{M}_2 \boldsymbol{M}_4^{-1} \boldsymbol{M}_3)^{-1} \\
&amp; \boldsymbol{T}_4 = (\boldsymbol{M}_4 - \boldsymbol{M}_3 \boldsymbol{M}_1^{-1} \boldsymbol{M}_2)^{-1} \\
\end{split}\end{split}\]</div>
</section>
<section id="center-of-diffusion">
<h3>Center of Diffusion<a class="headerlink" href="#center-of-diffusion" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.calc_CoD" title="pyrid.molecules.hydro_util.calc_CoD"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.calc_CoD</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/hydro_util.html#pyrid.molecules.hydro_util.center_of_mass" title="pyrid.molecules.hydro_util.center_of_mass"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.hydro_util.center_of_mass</span></code></a></p>
</div>
</details><p>One problem that arises with the above description is that we have not
yet formulated an expression for the center of diffusion of the rigid
bead molecule. For a rigid body immersed in a fluid, the force and
torque act at the body’s center of diffusion
<span id="id29">[<a class="reference internal" href="../../References.html#id19" title="Steven Harvey and Jose Garcia de la Torre. Coordinate systems for modeling the hydrodynamic resistance and diffusion coefficients of irregularly shaped rigid macromolecules. Macromolecules, 13(4):960–964, jul 1980. doi:10.1021/ma60076a037.">15</a>]</span>, which, in general, is different from
the center of mass except for spherically symmetric molecules. The
center of diffusion can, however, be calculated from a diffusion tensor
referring to an arbitrary origin by <span id="id30">[<a class="reference internal" href="../../References.html#id8" title="Beatriz Carrasco and José Garc\'ıa de la Torre. Hydrodynamic properties of rigid particles: comparison of different modeling and computational procedures. Biophysical Journal, 76(6):3044–3057, jun 1999. doi:10.1016/s0006-3495(99)77457-6.">2</a>]</span></p>
<div class="math notranslate nohighlight" id="equation-rod">
<span class="eqno">(43)<a class="headerlink" href="#equation-rod" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
\boldsymbol{r}_{OD}
= &amp;
\begin{pmatrix}
x_{OD} \\
y_{OD}\\
z_{OD}
\end{pmatrix} \\
= &amp;
\begin{pmatrix}
D_{rr}^{yy}+D_{rr}^{zz} &amp; -D_{rr}^{xy} &amp; -D_{rr}^{xz}\\
-D_{rr}^{xy} &amp; D_{rr}^{xx}+D_{rr}^{zz} &amp; -D_{rr}^{yz}\\
-D_{rr}^{xz} &amp; -D_{rr}^{yz} &amp; D_{rr}^{yy}+D_{rr}^{xx}
\end{pmatrix}^{-1}
\begin{pmatrix}
D_{tr}^{zy}-D_{tr}^{yz}\\
D_{tr}^{xz}-D_{tr}^{zx}\\
D_{tr}^{yx}-D_{tr}^{xy}
\end{pmatrix}
\end{split}.\end{split}\]</div>
</section>
</section>
<section id="compartments">
<span id="sec-compartments"></span><h2>Compartments<a class="headerlink" href="#compartments" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.Compartment" title="pyrid.system.system_util.Compartment"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.Compartment</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_border_3d" title="pyrid.system.system_util.System.add_border_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_border_3d</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_edges" title="pyrid.system.system_util.System.add_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_edges</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_mesh" title="pyrid.system.system_util.System.add_mesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_mesh</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_neighbours" title="pyrid.system.system_util.System.add_neighbours"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_neighbours</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.create_cell_list" title="pyrid.system.system_util.System.create_cell_list"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.create_cell_list</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.set_compartments" title="pyrid.system.system_util.System.set_compartments"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.set_compartments</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#module-pyrid.geometry.mesh_util" title="pyrid.geometry.mesh_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.closest_boundary_point" title="pyrid.geometry.mesh_util.closest_boundary_point"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.closest_boundary_point</span></code></a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.mesh_util.mesh_volume</span></code>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.point_triangle_distance" title="pyrid.geometry.mesh_util.point_triangle_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.point_triangle_distance</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.triangle_area" title="pyrid.geometry.mesh_util.triangle_area"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.triangle_area</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.triangle_centroid" title="pyrid.geometry.mesh_util.triangle_centroid"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.triangle_centroid</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.triangle_volume_signed" title="pyrid.geometry.mesh_util.triangle_volume_signed"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.triangle_volume_signed</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/mesh_util.html#pyrid.geometry.mesh_util.triangle_volume_signed" title="pyrid.geometry.mesh_util.triangle_volume_signed"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.mesh_util.triangle_volume_signed</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/geometry/load_wavefront.html#module-pyrid.geometry.load_wavefront" title="pyrid.geometry.load_wavefront"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.load_wavefront</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/load_wavefront.html#pyrid.geometry.load_wavefront.load_compartments" title="pyrid.geometry.load_wavefront.load_compartments"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.load_wavefront.load_compartments</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/geometry/ray_march_util.html#module-pyrid.geometry.ray_march_util" title="pyrid.geometry.ray_march_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.ray_march_util</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/ray_march_util.html#pyrid.geometry.ray_march_util.nearest_triangle" title="pyrid.geometry.ray_march_util.nearest_triangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.ray_march_util.nearest_triangle</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/ray_march_util.html#pyrid.geometry.ray_march_util.ray_march_surface" title="pyrid.geometry.ray_march_util.ray_march_surface"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.ray_march_util.ray_march_surface</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/ray_march_util.html#pyrid.geometry.ray_march_util.ray_march_volume" title="pyrid.geometry.ray_march_util.ray_march_volume"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.ray_march_util.ray_march_volume</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/ray_march_util.html#pyrid.geometry.ray_march_util.update_to_nearest_triangle" title="pyrid.geometry.ray_march_util.update_to_nearest_triangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.ray_march_util.update_to_nearest_triangle</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#module-pyrid.geometry.intersections_util" title="pyrid.geometry.intersections_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.any_ray_mesh_intersection_test" title="pyrid.geometry.intersections_util.any_ray_mesh_intersection_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.any_ray_mesh_intersection_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.edge_intersection_barycentric" title="pyrid.geometry.intersections_util.edge_intersection_barycentric"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.edge_intersection_barycentric</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.mesh_inside_box_test" title="pyrid.geometry.intersections_util.mesh_inside_box_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.mesh_inside_box_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.point_in_triangle_barycentric" title="pyrid.geometry.intersections_util.point_in_triangle_barycentric"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.point_in_triangle_barycentric</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.point_inside_AABB_test" title="pyrid.geometry.intersections_util.point_inside_AABB_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.point_inside_AABB_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.point_inside_mesh_test" title="pyrid.geometry.intersections_util.point_inside_mesh_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.point_inside_mesh_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.point_inside_mesh_test_raycasting" title="pyrid.geometry.intersections_util.point_inside_mesh_test_raycasting"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.point_inside_mesh_test_raycasting</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.point_inside_triangle_test" title="pyrid.geometry.intersections_util.point_inside_triangle_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.point_inside_triangle_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.ray_mesh_intersection_count" title="pyrid.geometry.intersections_util.ray_mesh_intersection_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.ray_mesh_intersection_count</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.ray_mesh_intersection_test" title="pyrid.geometry.intersections_util.ray_mesh_intersection_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.ray_mesh_intersection_test</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.ray_triangle_intersection" title="pyrid.geometry.intersections_util.ray_triangle_intersection"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.ray_triangle_intersection</span></code></a>
<a class="reference internal" href="../Developer%20API/geometry/intersections_util.html#pyrid.geometry.intersections_util.triangle_cell_intersection_test" title="pyrid.geometry.intersections_util.triangle_cell_intersection_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.geometry.intersections_util.triangle_cell_intersection_test</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/data_structures/cell_list_util.html#pyrid.data_structures.cell_list_util.create_cell_list_mesh" title="pyrid.data_structures.cell_list_util.create_cell_list_mesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.cell_list_util.create_cell_list_mesh</span></code></a>
<a class="reference internal" href="../Developer%20API/data_structures/cell_list_util.html#pyrid.data_structures.cell_list_util.CellListMesh" title="pyrid.data_structures.cell_list_util.CellListMesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.cell_list_util.CellListMesh</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.axis_angle_parameters" title="pyrid.math.transform_util.axis_angle_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.axis_angle_parameters</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.axis_halfangle_parameters" title="pyrid.math.transform_util.axis_halfangle_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.axis_halfangle_parameters</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.barycentric_coord" title="pyrid.math.transform_util.barycentric_coord"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.barycentric_coord</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.barycentric_coord_projection_method" title="pyrid.math.transform_util.barycentric_coord_projection_method"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.barycentric_coord_projection_method</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.barycentric_direction" title="pyrid.math.transform_util.barycentric_direction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.barycentric_direction</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.barycentric_params" title="pyrid.math.transform_util.barycentric_params"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.barycentric_params</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.cartesian_coord" title="pyrid.math.transform_util.cartesian_coord"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.cartesian_coord</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.cartesian_direction" title="pyrid.math.transform_util.cartesian_direction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.cartesian_direction</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.collision_response" title="pyrid.math.transform_util.collision_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.collision_response</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.cross" title="pyrid.math.transform_util.cross"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.cross</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.eij" title="pyrid.math.transform_util.eij"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.eij</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.ek" title="pyrid.math.transform_util.ek"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.ek</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.half_angle" title="pyrid.math.transform_util.half_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.half_angle</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.local_coord" title="pyrid.math.transform_util.local_coord"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.local_coord</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.normal_vector" title="pyrid.math.transform_util.normal_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.normal_vector</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.rodrigues_rot" title="pyrid.math.transform_util.rodrigues_rot"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.rodrigues_rot</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.solid_angle" title="pyrid.math.transform_util.solid_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.solid_angle</span></code></a>
<a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.tri_area_2D" title="pyrid.math.transform_util.tri_area_2D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.tri_area_2D</span></code></a></p>
</div>
</details><p>Compartmentalization plays an important role in cell processes.
Therefore, we would like to be able to restrict diffusion and reactions
to the volume and surface of arbitrarily shaped compartments. There
exist different methods to restrict the motion of particles to a
confined region. One option is to pattern the boundary of the
compartment with particles such that they interact with the particle
inside the compartment via a repulsive interaction potential. This
method, however, has several downsides. On the one hand, one needs many
particles to pattern the surface, which makes this method highly
inefficient. On the other hand this method does not support surface
diffusion in a straight forward way. Another approach would be to add
external potentials/force fields that restrict the motion of particles
either to the volume or the surface of a compartment. This method is
used in ReaDDy <span id="id31">[<a class="reference internal" href="../../References.html#id4" title="Moritz Hoffmann, Christoph Fröhner, and Frank Noé. ReaDDy 2: fast and flexible software framework for interacting-particle reaction dynamics. PLOS Computational Biology, 15(2):e1006830, feb 2019. doi:10.1371/journal.pcbi.1006830.">23</a>]</span>. However, complex
geometries/compartment shapes are more difficult to establish. A third
approach is to represent the compartment geometry by triangulated meshes
as is done, e.g. in MCell <span id="id32">[<a class="reference internal" href="../../References.html#id33" title="Rex A. Kerr, Thomas M. Bartol, Boris Kaminsky, Markus Dittrich, Jen-Chien Jack Chang, Scott B. Baden, Terrence J. Sejnowski, and Joel R. Stiles. Fast monte carlo simulation methods for biological reaction-diffusion systems in solution and on surfaces. SIAM Journal on Scientific Computing, 30(6):3126–3149, jan 2008. doi:10.1137/070692017.">10</a>]</span>. This approach
has several benefits over alternative approaches, such as representing
compartments by force fields or other particles. Triangulated meshes are
heavily used in computer graphics. Therefore, a large number of highly
optimized algorithms exist. Also, triangulated meshes are very well
suited to represent complex compartment geometries. In the following, I
will introduce how PyRID handles surface diffusion and collisions of
particles with compartment surfaces.</p>
<section id="triangulated-meshes">
<h3>Triangulated meshes<a class="headerlink" href="#triangulated-meshes" title="Permalink to this heading"></a></h3>
<p>A triangulated mesh surface is described by a set of <span class="math notranslate nohighlight">\(N\)</span> vertices.
These vertices are combined to sets of <span class="math notranslate nohighlight">\(n\)</span> vertices that form the
mesh faces. In our case, each face is a triangle (<span class="math notranslate nohighlight">\(n=3\)</span>)
determined by three vertices <span class="math notranslate nohighlight">\(\boldsymbol{p}_i, \boldsymbol{p}_j\)</span>
and <span class="math notranslate nohighlight">\(\boldsymbol{p}_k\)</span>. The order in which these vertices are
sorted per triangle determines the orientation of the triangle normal
vector. The normal vector of the triangle plane is given by
<span class="math notranslate nohighlight">\(\boldsymbol{n} = (\boldsymbol{p}_1-\boldsymbol{p}_0)\times(\boldsymbol{p}_2-\boldsymbol{p}_0)\)</span>.
In the following, I will write the three vertices of a triangle as
<span class="math notranslate nohighlight">\(\boldsymbol{p}_0, \boldsymbol{p}_1\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{p}_2\)</span>
and vertices are always sorted in counter clockwise order (Fig.
<a class="reference external" href="#fig:gedodesic_StanfordBunny">1.1</a> B). Thereby, the normal vector of
a triangle points outside the mesh compartment. In PyRID, a compartment
is defined by a triangulated manifold mesh, which is a mesh without
holes and disconnected vertices or edges, i.e. it has no gaps and
separates the space on the inside of the compartment from the space
outside <span id="id33">[<a class="reference internal" href="../../References.html#id10" title="Peter Shirley, Michael Ashikhmin, and Steve Marschner. Fundamentals of Computer Graphics. A K Peters/CRC Press, jul 2009. doi:10.1201/9781439865521.">34</a>]</span>. As one vertex is shared by at
minimum three triangles it is most convenient to store meshes in a
shared vertex mesh data structure <span id="id34">[<a class="reference internal" href="../../References.html#id10" title="Peter Shirley, Michael Ashikhmin, and Steve Marschner. Fundamentals of Computer Graphics. A K Peters/CRC Press, jul 2009. doi:10.1201/9781439865521.">34</a>]</span> where
an array with all vertex position vectors is kept as well as an array
holding for each triangle the indices of the three vertices that make up
the triangle (Fig. <a class="reference external" href="#fig:gedodesic_StanfordBunny">1.1</a> A).</p>
</section>
<section id="volume-molecules">
<span id="sec-vol-mol"></span><h3>Volume molecules<a class="headerlink" href="#volume-molecules" title="Permalink to this heading"></a></h3>
<p>The collision response of a molecule with the mesh is calculated in two
different ways. For large rigid bead molecules, each triangle exerts a
repulsive force on the individual beads; for small, isotropic molecules
or atoms, a ray tracing algorithm is used.</p>
<section id="contact-forces">
<h4>Contact forces<a class="headerlink" href="#contact-forces" title="Permalink to this heading"></a></h4>
<p>Contact detection generally consists of two phases, 1) neighbor
searching and 2) contact resolution. Contact detection and update of
contact forces can become fairly involved, depending on the required
accuracy, the surface complexity, the type of geometries involved, and
whether frictional forces need to be accounted for. Contact resolution
of the more complex type is found primarily in discrete element method
simulations <span id="id35">[<a class="reference internal" href="../../References.html#id34" title="L. Hu, G.M. Hu, Z.Q. Fang, and Y. Zhang. A new algorithm for contact detection between spherical particle and triangulated mesh boundary in discrete element method simulations. International Journal for Numerical Methods in Engineering, 94(8):787–804, mar 2013. doi:10.1002/nme.4487.">84</a>]</span>. Here, however, we will not
require exact accuracy but instead use a simple but, as I think,
sufficiently accurate approach. A bead <span class="math notranslate nohighlight">\(i\)</span> is said to be in
contact with a mesh element <span class="math notranslate nohighlight">\(j\)</span> (which can be a vertex, edge, or
face) if the minimum distance <span class="math notranslate nohighlight">\(r_{ij}\)</span> is smaller than the bead
radius. In this case, a repulsive force is exerted on the bead:</p>
<div class="math notranslate nohighlight">
\[U_{wall, i} = \sum_j^N \frac{k}{2} (r_{ij}-d)^2 \Omega_{ij}.\]</div>
<p>, where <span class="math notranslate nohighlight">\(k\)</span> is the force constant, <span class="math notranslate nohighlight">\(d\)</span> is the bead radius,
and <span class="math notranslate nohighlight">\(N\)</span> is the number of faces that are in contact with bead
<span class="math notranslate nohighlight">\(i\)</span>. In general, <span class="math notranslate nohighlight">\(\Omega_{ij}\)</span> accounts for the amount of
overlap of bead <span class="math notranslate nohighlight">\(i\)</span> with mesh face <span class="math notranslate nohighlight">\(j\)</span>. However, calculation
of <span class="math notranslate nohighlight">\(\Omega_{ij}\)</span> is computationally expensive. Therefore, we here
use a simple approximation <span class="math notranslate nohighlight">\(\Omega_{ij} = 1/N\)</span> with
<span class="math notranslate nohighlight">\(N = |\mathcal{F}|\)</span> where <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is the set of all
faces the bead is in contact with. Thereby, we assume that the bead
overlaps by the same amount with each mesh element and only account for
overlaps with faces as valid contacts but not edges or vertices. If
<span class="math notranslate nohighlight">\(\mathcal{F} = \emptyset\)</span>, only the distance to the closest mesh
element is used to calculate the repulsive force, which in this case is
either an edge or a vertex. To calculate the distance between the bead
and a triangle, PyRID uses the “Point to Triangle” algorithm by
<span id="id36">Eberly [<a class="reference internal" href="../../References.html#id39" title="David Eberly. 3D Game Engine Design. Morgan Kaufmann Publishers, 2001.">9</a>]</span>.</p>
</section>
<section id="ray-tracing">
<h4>Ray tracing<a class="headerlink" href="#ray-tracing" title="Permalink to this heading"></a></h4>
<p>Contact force calculations are disadvantageous for small, spherical
molecules because they require a very small integration time step. Here,
ray tracing is more convenient as it works independently of the chosen
integration time step. In this approach, which is similar to the contact
detection used in MCell <span id="id37">[<a class="reference internal" href="../../References.html#id33" title="Rex A. Kerr, Thomas M. Bartol, Boris Kaminsky, Markus Dittrich, Jen-Chien Jack Chang, Scott B. Baden, Terrence J. Sejnowski, and Joel R. Stiles. Fast monte carlo simulation methods for biological reaction-diffusion systems in solution and on surfaces. SIAM Journal on Scientific Computing, 30(6):3126–3149, jan 2008. doi:10.1137/070692017.">10</a>]</span>, the displacement
vector <span class="math notranslate nohighlight">\(\boldsymbol{\Delta R}\)</span> of the molecule is traced through
the simulation volume and collisions with the compartment boundary (the
mesh) are resolved via reflection.</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\Delta R}_{refl} = \boldsymbol{\Delta R} - 2 (\boldsymbol{\Delta R} \cdot \hat{\boldsymbol{n}}) \hat{\boldsymbol{n}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\boldsymbol{n}}\)</span> is the normal vector of the triangle
face. Collision tests are done using the “Fast Voxel Traversal Algorithm
for Ray Tracing” introduced by <span id="id38">Amanatides and Woo [<a class="reference internal" href="../../References.html#id38" title="John Amanatides and Andrew Woo. A fast voxel traversal algorithm for ray tracing. In In Eurographics ’87, 3–10. 1987.">5</a>]</span>.</p>
</section>
</section>
<section id="surface-molecules">
<h3>Surface molecules<a class="headerlink" href="#surface-molecules" title="Permalink to this heading"></a></h3>
<p>Surface molecules laterally diffuse within the mesh surface and can
represent any transmembrane molecules such as receptors. Here, I take a
similar approach to MCell. Thereby, a molecule diffuses in the plane of
a triangle until it crosses a triangle edge. In this case, the
molecule’s displacement vector <span class="math notranslate nohighlight">\(\Delta R\)</span> is advanced until that
edge and then rotated into the plane of the neighboring triangle where
the rotation axis is given by the shared triangle edge. Thereby, the
molecule will move in a strait line on the mesh surface (Figure
<a class="reference external" href="#fig:gedodesic_StanfordBunny">1.1</a> C-E). This method is equivalent
to unfolding the triangles over the shared edge such that they end up in
a common tangent space, i.e. such that they are co-planar, advancing the
position vector, and folding/rotating back. From the latter method it
becomes intuitively clear that the molecule will indeed move in a
straight line on the mesh surface. In the following I will introduce the
details of the method sketched above.</p>
<figure class="align-default" id="fig-gedodesic-stanfordbunny">
<a class="reference internal image-reference" href="../../_images/Fig_Geodesics.png"><img alt="../../_images/Fig_Geodesics.png" src="../../_images/Fig_Geodesics.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 15 </span><span class="caption-text"><strong>Mesh compartments and surface molecules.</strong> <strong>(A)</strong> PyRID uses
triangulated meshes to represent compartments. These are kept in a
shared vertex mesh data structure (top left, right)
<span id="id39">[<a class="reference internal" href="../../References.html#id10" title="Peter Shirley, Michael Ashikhmin, and Steve Marschner. Fundamentals of Computer Graphics. A K Peters/CRC Press, jul 2009. doi:10.1201/9781439865521.">34</a>]</span>. In addition, for neighbour search,
two array that hold for each triangle the vertex indices of the three
triangle edges and the triangle indices of the three triangle
neighbours are used. <strong>(A)</strong> Triangle vertices belonging to a
triangle are ordered counterclockwise, as are edges. For in triangle
and edge intersection tests barycentric triangle coordinates are
used. <strong>(A)</strong> Visualization of mesh surface ray marching. If a
molecule (green sphere) crosses a triangle edge, its displacement
vector is advanced to the corresponding edge and then rotated into
the plane of the neighboring triangle. <strong>D,E</strong> By the ray marching
method described in the text, molecules follow a geodesic paths on
the mesh surface. <strong>F</strong> The mean squared displacement of diffusing
surface molecules is in agreement with theory.</span><a class="headerlink" href="#fig-gedodesic-stanfordbunny" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="surface-ray-marching">
<h4>Surface ray marching<a class="headerlink" href="#surface-ray-marching" title="Permalink to this heading"></a></h4>
<p>First, we need to be able to detect if a triangle edge has been crossed,
and to which neighbouring triangle this edge belongs. Therefore, in
addition to the triangle and vertex data, for each triangle, the vertex
indices of the three triangle edges are kept in an array (Fig.
<a class="reference external" href="#fig:gedodesic_StanfordBunny">1.1</a>A). Edges are sorted in counter
clockwise order. Also, for each of the three edges the index of the
corresponding neighbouring triangle is kept in a separate array for fast
lookup (Fig. <a class="reference external" href="#fig:gedodesic_StanfordBunny">1.1</a>A).</p>
<p>The triangle edge intersection test can be made efficient by the use of
barycentric coordinates. Let
<span class="math notranslate nohighlight">\(\boldsymbol{p}_0, \boldsymbol{p}_1, \boldsymbol{p}_2\)</span> be the
three vertices of a triangle. Also, the vertices are numbered in counter
clockwise order and the triangle origin is at <span class="math notranslate nohighlight">\(\boldsymbol{p}_0\)</span>.
Then, the center of the molecule <span class="math notranslate nohighlight">\(R_0\)</span> can be described in
barycentric coordinates by</p>
<div class="math notranslate nohighlight" id="equation-eq-barycentric-coord-1">
<span class="eqno">(44)<a class="headerlink" href="#equation-eq-barycentric-coord-1" title="Permalink to this equation"></a></span>\[\boldsymbol{R}_0 = \boldsymbol{p}_0 + u(\boldsymbol{p}_1-\boldsymbol{p}_0) + v (\boldsymbol{p}_2-\boldsymbol{p}_0),\]</div>
<p>and the molecule displacement vector by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\Delta R} = du(\boldsymbol{p}_1-\boldsymbol{p}_0) + dv (\boldsymbol{p}_2-\boldsymbol{p}_0),\]</div>
<p>Efficient algorithms to compute the barycentric coordinates <span class="math notranslate nohighlight">\(u\)</span>
and <span class="math notranslate nohighlight">\(v\)</span> can, e.g., be found in <span id="id40">[<a class="reference internal" href="../../References.html#id40" title="Christer Ericson. Real-Time Collision Detection. CRC Press, dec 2004. doi:10.1201/b14581.">6</a>]</span>.
The triangle edges are sorted in counter clockwise order, starting from
the triangle origin <span class="math notranslate nohighlight">\(\boldsymbol{p}_0\)</span>. As such, we are on the
line <span class="math notranslate nohighlight">\(\boldsymbol{p}_0 + u(\boldsymbol{p}_1-\boldsymbol{p}_0)\)</span>
(edge 0) if <span class="math notranslate nohighlight">\(v=0\)</span>, on the line
<span class="math notranslate nohighlight">\(\boldsymbol{p}_0 + v (\boldsymbol{p}_2-\boldsymbol{p}_0)\)</span> (edge
2) if <span class="math notranslate nohighlight">\(u = 0\)</span> and on the line
<span class="math notranslate nohighlight">\(u \boldsymbol{p}_1 + v \boldsymbol{p}_2\)</span> (edge 1) if
<span class="math notranslate nohighlight">\(u+v=1\)</span>. Thereby, the edge intersection test comes down to solving</p>
<div class="math notranslate nohighlight" id="equation-edge-intersection">
<span class="eqno">(45)<a class="headerlink" href="#equation-edge-intersection" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
&amp; u+t_{1}\cdot du = 0 \\
&amp; v+t_{0}\cdot dv = 0 \\
&amp; (u+t_{2} \cdot du) + (v+t_{2} \cdot dv) = 1 ,
\end{split}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(t_{i}\)</span> with <span class="math notranslate nohighlight">\(i \in \{0,1,2\}\)</span> is the distances to the
respective edge <span class="math notranslate nohighlight">\(i\)</span> along the displacement vector. We find that
the intersections occur at</p>
<div class="math notranslate nohighlight" id="equation-edge-intersection2">
<span class="eqno">(46)<a class="headerlink" href="#equation-edge-intersection2" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
&amp; t_{1} = -\frac{u}{du} \,\, (\text{edge 1}) \\
&amp; t_{0}=-\frac{v}{dv} \,\, (\text{edge 0})\\
&amp; t_{2}=\frac{1-u-v}{du+dv} \,\, (\text{edge 2}) .
\end{split}\end{split}\]</div>
<p>To determine with which edge
<span class="math notranslate nohighlight">\(\boldsymbol{R}+\boldsymbol{\Delta R}\)</span> intersects first, we simply
need to check for the smallest positive value of <span class="math notranslate nohighlight">\(t_{i}\)</span>.
Afterward, we advance <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> to the intersecting edge,
reduce <span class="math notranslate nohighlight">\(\boldsymbol{\Delta R}\)</span> by the corresponding distance
traveled and transform <span class="math notranslate nohighlight">\(\boldsymbol{R}\)</span> to the local coordinate
frame of the neighboring triangle. At last,
<span class="math notranslate nohighlight">\(\boldsymbol{\Delta R}\)</span> is rotated into the plane of the
neighboring triangle. This can be done efficiently using Rodrigues’
rotation formula</p>
<div class="math notranslate nohighlight" id="equation-eq-rodrigues">
<span class="eqno">(47)<a class="headerlink" href="#equation-eq-rodrigues" title="Permalink to this equation"></a></span>\[\Delta \boldsymbol{R}_{rot} = \Delta \boldsymbol{R} \cos(\phi) + (\boldsymbol{a}_n \times \Delta \boldsymbol{R}) \sin(\phi) + \boldsymbol{a}_n (\boldsymbol{a}_n \cdot \Delta \boldsymbol{R}) (1-\cos(\phi)),\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eq-cos-sin-phi">
<span class="eqno">(48)<a class="headerlink" href="#equation-eq-cos-sin-phi" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}
&amp; \cos(\phi) = \frac{\hat{\boldsymbol{n}}_1 \cdot \hat{\boldsymbol{n}}_2}{|\hat{\boldsymbol{n}}_1| |\hat{\boldsymbol{n}}_2|} \\
&amp; \sin(\phi) = \frac{\hat{\boldsymbol{n}}_1 \times \hat{\boldsymbol{n}}_2}{|\hat{\boldsymbol{n}}_1| |\hat{\boldsymbol{n}}_2|}
\end{split}.\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\hat{\boldsymbol{n}}_1\)</span> and <span class="math notranslate nohighlight">\(\hat{\boldsymbol{n}}_2\)</span>
are the normal vectors of the two neighboring triangles. As PyRID
supports anisotropic rigid bead molecules, the orientation of the
molecule needs to be updated as well for each triangle that is crossed.
It is not sufficient, however, to rotate the molecule only after it has
reached its final position, because the final orientation depends on the
exact path that is taken (in case multiple triangles are crossed) and
not only on the normal vector/orientation of the target triangle plane.
The rotation quaternion is given by:</p>
<div class="math notranslate nohighlight" id="equation-eq-quaternion-cos-sin-phi">
<span class="eqno">(49)<a class="headerlink" href="#equation-eq-quaternion-cos-sin-phi" title="Permalink to this equation"></a></span>\[\boldsymbol{q} = \cos(\phi/2) + \boldsymbol{a}_{n} \sin(\phi/2),\]</div>
<p>where <span class="math notranslate nohighlight">\(\sin(\phi/2)\)</span> and <span class="math notranslate nohighlight">\(\cos(\phi/2)\)</span> can be calculated
from the half-angle formulas for sine and cosine such that the
<span class="math notranslate nohighlight">\(\cos(\phi)\)</span> and <span class="math notranslate nohighlight">\(\sin(\phi)\)</span> that were calculated to rotate
<span class="math notranslate nohighlight">\(\Delta R\)</span> can be reused. The molecule’s orientation quaternion is
than propagated by quaternion multiplication. The procedure is stopped
if <span class="math notranslate nohighlight">\(\boldsymbol{R}_0 +\Delta \boldsymbol{R}\)</span> end up inside the
triangle the molecule is currently located on, i.e. if
<span class="math notranslate nohighlight">\(0&lt;=u&lt;=1, 0&lt;=v&lt;=1, u+v&lt;=1\)</span>.</p>
</section>
<section id="integrating-the-equation-of-motion">
<h4>Integrating the equation of motion<a class="headerlink" href="#integrating-the-equation-of-motion" title="Permalink to this heading"></a></h4>
<p>Because in PyRID the mobility of each molecule is described by the
mobility tensor in the local frame instead of a scalar mobility
coefficient, integrating the equation of motion for surface molecules
becomes straight forward. Here, we can simply skip the z components in
the integration scheme (Eqs.<a class="reference internal" href="#equation-eq-drdt">(32)</a>,
<a class="reference internal" href="#equation-eq-dqdt">(35)</a>). Otherwise, we would need to calculate the
tangent external and Brownian force vectors.</p>
</section>
</section>
</section>
<section id="boundary-conditions">
<h2>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System" title="pyrid.system.system_util.System"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System</span></code></a></p>
</div>
</details><p>PyRID supports three kinds of boundary conditions:</p>
<ol class="arabic simple">
<li><p>Periodic,</p></li>
<li><p>repulsive and</p></li>
<li><p>fixed concentration boundary conditions.</p></li>
</ol>
<p>Repulsive boundary conditions are handled either by a repulsive
interaction potential or via ray tracing, depending on the molecule type
(see section 1.5.2 <a class="reference internal" href="#sec-vol-mol"><span class="std std-ref">Volume molecules</span></a>). For periodic boundary
conditions, the minimal image convention is applied (Fig.
<a class="reference external" href="#fig:fixed_concentration">[fig:fixed_concentration]</a> C). Thereby,
each particle only interacts with the closest image of the other
particles in the system. Note, however, that the box size must not
become too small, otherwise particles start to interact with themselves.
As periodic and repulsive boundary conditions are very common, I will,
in the following only introduce the fixed concentration boundary
conditions in more detail, which is a feature unique to PyRID.</p>
<section id="fixed-concentration-boundary-conditions">
<h3>Fixed concentration boundary conditions<a class="headerlink" href="#fixed-concentration-boundary-conditions" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_border_3d" title="pyrid.system.system_util.System.add_border_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_border_3d</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.fixed_concentration_at_boundary" title="pyrid.system.system_util.System.fixed_concentration_at_boundary"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.fixed_concentration_at_boundary</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/random_util.html#pyrid.math.random_util.dx_cum_prob" title="pyrid.math.random_util.dx_cum_prob"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.random_util.dx_cum_prob</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.release_molecules_boundary" title="pyrid.system.distribute_vol_util.release_molecules_boundary"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.release_molecules_boundary</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.random_point_on_edge" title="pyrid.system.distribute_surface_util.random_point_on_edge"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.random_point_on_edge</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.release_molecules_boundary_2d" title="pyrid.system.distribute_surface_util.release_molecules_boundary_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.release_molecules_boundary_2d</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.random_point_in_triangle" title="pyrid.system.distribute_surface_util.random_point_in_triangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.random_point_in_triangle</span></code></a></p>
</div>
</details><p>Fixed concentration boundary conditions couple the simulation box to a
particle bath. Thereby, we can simulate, e.g., a sub-region within a
larger system without the need to simulate the dynamics of the molecules
outside simulation box directly. Instead, molecules that are outside the
simulation box are treated as ’virtual’ molecules that only become part
of the simulation if they cross the simulation box border. In PyRID it
is possible to have mesh compartments intersect with the simulation box
boundary. Molecules then enter and exit the simulation across the
intersection surface or the intersection line in the case of surface
molecules.</p>
<p>Each iteration of a simulation, the expected number of hits between a
molecule type and simulation box borders are calculated. The number of
hits depends on the outside concentration of the molecule, the diffusion
coefficient and the border surface area. The average number of volume
molecules that hit a boundary of area <span class="math notranslate nohighlight">\(A\)</span> from one side within a
time step <span class="math notranslate nohighlight">\(\Delta t\)</span> can be calculated from the molecule
concentration <span class="math notranslate nohighlight">\(C\)</span> and the average distance a diffusing molecule
travels normal to a plane <span class="math notranslate nohighlight">\(l_{n}\)</span> within <span class="math notranslate nohighlight">\(\Delta t\)</span>
<span id="id41">[<a class="reference internal" href="../../References.html#id33" title="Rex A. Kerr, Thomas M. Bartol, Boris Kaminsky, Markus Dittrich, Jen-Chien Jack Chang, Scott B. Baden, Terrence J. Sejnowski, and Joel R. Stiles. Fast monte carlo simulation methods for biological reaction-diffusion systems in solution and on surfaces. SIAM Journal on Scientific Computing, 30(6):3126–3149, jan 2008. doi:10.1137/070692017.">10</a>]</span>:</p>
<div class="math notranslate nohighlight">
\[N_{hits} = \frac{A l_{n}}{2 C},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[l_{n} = \sqrt{\frac{4D\Delta t}{\pi}}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(D = Tr(\boldsymbol{D}^{tt,b})/3\)</span> is the scalar translational
diffusion coefficient. For surface molecules
<span class="math notranslate nohighlight">\(D = Tr(\boldsymbol{D}_{xy}^{tt,b})/2\)</span> and</p>
<div class="math notranslate nohighlight">
\[N_{hits} = \frac{L l_{n}}{2 C},\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is the length of the boundary edge. The boundary
crossing of molecules can be described as a Poisson process. As such,
the number of molecules that cross the boundary each time step is drawn
from a Poisson distribution with a rate <span class="math notranslate nohighlight">\(N_{hits}\)</span>.</p>
<p>The normalized distance that a crossing molecule ends up away from the
plane/boundary follows distribution <span id="id42">[<a class="reference internal" href="../../References.html#id33" title="Rex A. Kerr, Thomas M. Bartol, Boris Kaminsky, Markus Dittrich, Jen-Chien Jack Chang, Scott B. Baden, Terrence J. Sejnowski, and Joel R. Stiles. Fast monte carlo simulation methods for biological reaction-diffusion systems in solution and on surfaces. SIAM Journal on Scientific Computing, 30(6):3126–3149, jan 2008. doi:10.1137/070692017.">10</a>]</span>:</p>
<div class="math notranslate nohighlight">
\[P(d\tilde{x}) = 1-e^{-d\tilde{x}^2}+\sqrt{\pi}*dx*\text{erfc}(d\tilde{x})\]</div>
<p>The distance vector normal to the plane after the crossing can then be
calculated from the diffusion length constant <span class="math notranslate nohighlight">\(\lambda\)</span> and the
plane’s normal vector <span class="math notranslate nohighlight">\(\hat{\boldsymbol{n}}\)</span> by
<span class="math notranslate nohighlight">\(d\boldsymbol{x} = \lambda \, d\tilde{x} \, \hat{\boldsymbol{n}} = \sqrt{4Dt} \, d\tilde{x} \, \hat{\boldsymbol{n}}\)</span>.</p>
<p>In the case that a molecule enters the simulation box close to another
boundary, e.g. of a mesh compartment, we may also want to account for
the distance traveled parallel to the plane in order to correctly
resolve collision with the mesh. However, currently PyRID does not
account for this. For small integration time steps and meshes that are
further than <span class="math notranslate nohighlight">\(\sqrt{4Dt}\)</span> away from the simulation box border, the
error introduced should, however, be negligible.</p>
<p>Now that the number of molecules and their distance away from the plane
are determined, the molecules are distributed in the simulation box.
Since the diffusion along each dimension is independent we can simply
pick a random point uniformly distributed on the respective plane. For
triangulated mesh surfaces, triangles are picked randomly, weighted by
their area. Sampling a uniformly distributed random point in a triangle
is done by <span id="id43">[<a class="reference internal" href="../../References.html#id54" title="Robert Osada, Thomas Funkhouser, Bernard Chazelle, and David Dobkin. Shape distributions. ACM Transactions on Graphics, 21(4):807–832, oct 2002. doi:10.1145/571647.571648.">26</a>]</span></p>
<div class="math notranslate nohighlight">
\[P(\boldsymbol{r}) = (1-\sqrt{\mu_1})*\boldsymbol{p}_0+(\sqrt{\mu_1}*(1-\mu_2))*\boldsymbol{p}_1+(\mu_2*\sqrt{\mu_1})*\boldsymbol{p}_2  ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_1, \mu_2\)</span> are random numbers between 0 and 1.
<span class="math notranslate nohighlight">\(\boldsymbol{p}_0, \boldsymbol{p}_1, \boldsymbol{p}_2\)</span> are the
three vertices of the triangle.</p>
<p>Note that, in general, any interactions between the virtual molecules
are not accounted for. Therefore, fixed concentration boundary
conditions only result in the same inside and outside concentrations if
no molecular interactions are simulated.</p>
<figure class="align-default" id="fig-boundaries">
<a class="reference internal image-reference" href="../../_images/Boundaries.png"><img alt="../../_images/Boundaries.png" src="../../_images/Boundaries.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 16 </span><span class="caption-text"><strong>Boundaries.</strong> <strong>A</strong> (left, middle) In PyRID, the user can define
different face groups. Face groups can be used, e.g., to distribute
molecules on specific regions of the mesh surface (blue). When a
compartment intersects with the simulation box, the intersecting
triangles are assigned to a transparent class (yellow), as are the
corresponding edges that intersect with the boundary (purple lines).
If boundary conditions are set to “fixed concentration” transparent
triangles and edges act as absorbing boundaries but in addition
release new molecules into the simulation volume. (Right) The same is
the case for those parts of the simulation box border that is not
intersecting with one of the compartments. <strong>B</strong> For periodic
boundary conditions, PyRID follows the minimal image convention, i.e.
a particle (black marker) only interacts (colored arrows) with the
closest image (grey marker) of the other particles in the system.</span><a class="headerlink" href="#fig-boundaries" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="reactions">
<span id="sec-reactions"></span><h2>Reactions<a class="headerlink" href="#reactions" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.reactions_registry_util</span></code>
<a class="reference internal" href="../Developer%20API/reactions/reactions_registry_util.html#pyrid.reactions.reactions_registry_util.Reaction" title="pyrid.reactions.reactions_registry_util.Reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.reactions_registry_util.Reaction</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#module-pyrid.reactions.update_reactions" title="pyrid.reactions.update_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.convert_molecule_type" title="pyrid.reactions.update_reactions.convert_molecule_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.convert_molecule_type</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.convert_particle_type" title="pyrid.reactions.update_reactions.convert_particle_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.convert_particle_type</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.delete_molecule" title="pyrid.reactions.update_reactions.delete_molecule"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.delete_molecule</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.delete_particles" title="pyrid.reactions.update_reactions.delete_particles"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.delete_particles</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.delete_reactions" title="pyrid.reactions.update_reactions.delete_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.delete_reactions</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/update_reactions.html#pyrid.reactions.update_reactions.update_reactions" title="pyrid.reactions.update_reactions.update_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.update_reactions.update_reactions</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/update_force.html#pyrid.system.update_force.react_interact_test" title="pyrid.system.update_force.react_interact_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.update_force.react_interact_test</span></code></a>
<a class="reference internal" href="../Developer%20API/system/update_force.html#pyrid.system.update_force.update_force_append_reactions" title="pyrid.system.update_force.update_force_append_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.update_force.update_force_append_reactions</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/molecules/rigidbody_util.html#pyrid.molecules.rigidbody_util.RBs.next_um_reaction" title="pyrid.molecules.rigidbody_util.RBs.next_um_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.rigidbody_util.RBs.next_um_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/particles_util.html#pyrid.molecules.particles_util.Particles.next_up_reaction" title="pyrid.molecules.particles_util.Particles.next_up_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.particles_util.Particles.next_up_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/particles_util.html#pyrid.molecules.particles_util.Particles.clear_number_reactions" title="pyrid.molecules.particles_util.Particles.clear_number_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.particles_util.Particles.clear_number_reactions</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/particles_util.html#pyrid.molecules.particles_util.Particles.decrease_number_reactions" title="pyrid.molecules.particles_util.Particles.decrease_number_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.particles_util.Particles.decrease_number_reactions</span></code></a>
<a class="reference internal" href="../Developer%20API/molecules/particles_util.html#pyrid.molecules.particles_util.Particles.increase_number_reactions" title="pyrid.molecules.particles_util.Particles.increase_number_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.molecules.particles_util.Particles.increase_number_reactions</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.MoleculeType.update_um_reaction" title="pyrid.system.system_util.MoleculeType.update_um_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.MoleculeType.update_um_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_bm_reaction" title="pyrid.system.system_util.System.add_bm_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_bm_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_bp_reaction" title="pyrid.system.system_util.System.add_bp_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_bp_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_interaction" title="pyrid.system.system_util.System.add_interaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_interaction</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_um_reaction" title="pyrid.system.system_util.System.add_um_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_um_reaction</span></code></a>
<a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_up_reaction" title="pyrid.system.system_util.System.add_up_reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_up_reaction</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/random_util.html#pyrid.math.random_util.bisect_right" title="pyrid.math.random_util.bisect_right"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.random_util.bisect_right</span></code></a>
<a class="reference internal" href="../Developer%20API/math/random_util.html#pyrid.math.random_util.random_choice" title="pyrid.math.random_util.random_choice"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.random_util.random_choice</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.normal" title="pyrid.system.distribute_vol_util.normal"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.normal</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.point_in_sphere_simple" title="pyrid.system.distribute_vol_util.point_in_sphere_simple"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.point_in_sphere_simple</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.point_on_sphere" title="pyrid.system.distribute_vol_util.point_on_sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.point_on_sphere</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.random_direction_Halfsphere" title="pyrid.system.distribute_vol_util.random_direction_Halfsphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.random_direction_Halfsphere</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.random_direction_sphere" title="pyrid.system.distribute_vol_util.random_direction_sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.random_direction_sphere</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.trace_direction_vector" title="pyrid.system.distribute_vol_util.trace_direction_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.trace_direction_vector</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.point_in_disc" title="pyrid.system.distribute_surface_util.point_in_disc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.point_in_disc</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.trace_direction_vector" title="pyrid.system.distribute_surface_util.trace_direction_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.trace_direction_vector</span></code></a></p>
</div>
</details><p>In this section, methods to simulate reactions between proteins and
other molecules are introduced. Reactions include, for example,
post-translational modifications such as phosphorylation or
ubiquitination or binding of ligands and ATP. This list could be
continued. In PyRID, reactions are described on several different
levels. As a result of rigid bead molecules consisting of one or several
subunits, reactions can be defined either on the molecule level or on
the bead/particle level. In addition, reactions are categorized into
bi-molecular (second order) and uni-molecular (first order) and zero
order reactions. Each uni- and bimolecular reaction can consist of
several different reaction paths, each belonging to a different reaction
type (for an overview see Fig. <a class="reference external" href="#fig:ReactionsGraph">1.3</a>).
Uni-molecular reactions are divided into the following categories:</p>
<ol class="arabic simple">
<li><p>decay reactions,</p></li>
<li><p>fission reactions,</p></li>
<li><p>conversion reactions.</p></li>
</ol>
<p>Decay reactions account for the degradation of proteins whereas fission
reactions can be used to describe ligand unbinding but also, e.g., the
disassembly of protein complexes or even the flux of ions in response to
ion channel opening. Conversion reactions on the other hand may be used
to describe different folded protein states that change the protein
properties, post-translational modifications but also binding and
unbinding reactions in the case where we do not need to model the
ligands explicitly (which is the case, e.g. if we can assume an infinite
ligand pool). Bi-molecular reactions are divided into</p>
<ol class="arabic simple">
<li><p>fusion reactions,</p></li>
<li><p>enzymatic reactions.</p></li>
<li><p>binding reactions</p></li>
</ol>
<p>Fusion reactions can, e.g., describe protein complex formation or ligand
binding.</p>
<p>As mentioned above, each uni- and bi-molecular reaction can consist of
one or several reaction paths. This is motivated by the minimal
coarse-graining approach we take. Two proteins, e.g., can have different
sites by which they interact. However, these are not necessarily
represented in the rigid bead model. Similarly, a protein may convert to
one of a larger set of possible states. And again, the list could be
continued. In the following sections I will describe the methods by
which reactions are executed in PyRID in more detail.</p>
<figure class="align-default" id="fig-reactionsgraph">
<a class="reference internal image-reference" href="../../_images/Reactions_Graph.png"><img alt="../../_images/Reactions_Graph.png" src="../../_images/Reactions_Graph.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 17 </span><span class="caption-text"><strong>Reactions graph.</strong> PyRID supports various kinds of bimolecular and
unimolecular reactions. The trees give an overview about the possible
reactions and reaction paths. Bimolecular reactions are always
associated with one or several particle pairs. A reaction can always
have one or several possible reaction products by having different
reaction paths.</span><a class="headerlink" href="#fig-reactionsgraph" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="unimolecular-reactions">
<h3>Unimolecular reactions<a class="headerlink" href="#unimolecular-reactions" title="Permalink to this heading"></a></h3>
<p>Unimolecular reactions include fission, conversion, and decay reactions.
These can be efficiently simulated using a variant of the Gillespie
Stochastic Simulation Algorithm (SSA)
<span id="id44">[<a class="reference internal" href="../../References.html#id6" title="Radek Erban, Jonathan Chapman, and Philip Maini. A practical guide to stochastic simulations of reaction-diffusion processes. 2007. doi:10.48550/ARXIV.0704.1908.">12</a>, <a class="reference internal" href="../../References.html#id32" title="Daniel T. Gillespie. Exact stochastic simulation of coupled chemical reactions. The Journal of Physical Chemistry, 81(25):2340–2361, dec 1977. doi:10.1021/j100540a008.">85</a>]</span>. Thereby, the time point
of the next reaction is sampled from the probability distribution of
expected molecule lifetimes, assuming that in between two time points no
interfering event occurs. An interfering event could, e.g., be a
bi-molecular reaction. The naive way of simulating uni-molecular
reactions would be to check each time step whether the reaction will
occur depending on its reaction rate. The Gillespie SSA has the benefit
of being exact (partially true since the simulation evolves in finite,
discrete time steps) and far more efficient, because we only need to
evaluate a reaction once and not each time step. For a single molecule
having <span class="math notranslate nohighlight">\(n\)</span> possible reaction paths each with a reaction rate
<span class="math notranslate nohighlight">\(k_i\)</span>, let <span class="math notranslate nohighlight">\(k_t = \sum_i^n k_i\)</span> be the total reaction rate.
Let <span class="math notranslate nohighlight">\(\rho(\tau) d\tau\)</span> be the probability that the next reaction
occurs within <span class="math notranslate nohighlight">\([t+\tau,t+\tau+d\tau)\)</span>, which can be split into
<span class="math notranslate nohighlight">\(g(\tau)\)</span>, the probability that no reaction occurs within
<span class="math notranslate nohighlight">\([t,t+\tau)\)</span> and probability that a reaction occurs within the
time interval <span class="math notranslate nohighlight">\(d\tau\)</span>, which is given by <span class="math notranslate nohighlight">\(k_t d\tau\)</span>.
Thereby,</p>
<div class="math notranslate nohighlight">
\[\rho(\tau) d\tau = g(\tau) k_t d\tau,\]</div>
<p>where <span class="math notranslate nohighlight">\(g(\tau) = e^{-k_t \tau}\)</span> <span id="id45">[<a class="reference internal" href="../../References.html#id6" title="Radek Erban, Jonathan Chapman, and Philip Maini. A practical guide to stochastic simulations of reaction-diffusion processes. 2007. doi:10.48550/ARXIV.0704.1908.">12</a>]</span>.
From the above equation we find <span class="math notranslate nohighlight">\(P(\tau) = 1-e^{-k_t \tau}\)</span> by
integration. To sample from this distribution, we can use the inverse
distribution function.</p>
<div class="math notranslate nohighlight">
\[\tau = P^{-1}(U)\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> is uniformly distributed in <span class="math notranslate nohighlight">\((0,1)\)</span>. From
<span class="math notranslate nohighlight">\(U = P(\tau) = 1-e^{-k_t \tau}\)</span>, we find
<span class="math notranslate nohighlight">\(P^{-1}(U) = \frac{-log(1-U)}{k_t}\)</span>. Since <span class="math notranslate nohighlight">\(U\)</span> is uniformly
distributed in <span class="math notranslate nohighlight">\((0,1)\)</span>, so is <span class="math notranslate nohighlight">\(1-U\)</span>. Thereby, we can draw
the time point of the next reaction from:</p>
<div class="math notranslate nohighlight">
\[\tau = \frac{1}{k_t} \ln\Big[\frac{1}{U}\Big],\]</div>
<p>With the above method, we accurately sample from the distribution of
expected molecule lifetimes <span class="math notranslate nohighlight">\(\rho(\tau) = k_t e^{-k_t \tau}\)</span>.</p>
<p>At the time point of the reaction, we can sample from the set of
reaction paths by a weighted random choice algorithm. Therefore, we
compare a second random number, uniformly distributed in
<span class="math notranslate nohighlight">\((0,k_{t})\)</span>, with the cumulative set of reaction rates
<span class="math notranslate nohighlight">\((k_1, k_1+k_2, ... ,k_{t})\)</span>. The comparison can be made
efficiently via a bisection algorithm.</p>
<section id="particle-and-molecule-reactions">
<h4>Particle and molecule reactions<a class="headerlink" href="#particle-and-molecule-reactions" title="Permalink to this heading"></a></h4>
<p>Because in PyRID, molecules are represented by rigid bead models,
uni-molecular reactions can occur either on the molecule level or on the
particle level. As such, if a conversion or decay reaction is defined on
a molecule, executing the reaction will exchange the complete rigid bead
molecule by a product molecule, or, in the case of a decay reaction,
will remove the complete molecule from the simulation. On the other
hand, if the reactions are defined on a particle/bead type, only the
particle will be affected. Whereas decay and conversion reactions are
handled very similar for molecules and particles, fission reactions are
handled slightly different. Therefore, PyRID offers three types of
fission reactions:</p>
<ol class="arabic simple">
<li><p>fission reactions,</p></li>
<li><p>production reactions,</p></li>
<li><p>release reactions.</p></li>
</ol>
<p><em>Standard fission reactions</em> can only be defined on the molecule level
and are executed similar to ReaDDy <span id="id46">[<a class="reference internal" href="../../References.html#id4" title="Moritz Hoffmann, Christoph Fröhner, and Frank Noé. ReaDDy 2: fast and flexible software framework for interacting-particle reaction dynamics. PLOS Computational Biology, 15(2):e1006830, feb 2019. doi:10.1371/journal.pcbi.1006830.">23</a>]</span>.
Here, the number of product molecules is limited to two. In the case
where educt and products are volume molecules, the product molecules are
placed within a sphere of radius <span class="math notranslate nohighlight">\(R_{fission}\)</span>. Therefore, an
orientation vector <span class="math notranslate nohighlight">\(\boldsymbol{d}\)</span> uniformly distributed in the
rotation space with a length <span class="math notranslate nohighlight">\(&lt;=R_{fission}\)</span> is sampled. The two
products are then placed according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
    \boldsymbol{r}_1 = \boldsymbol{r}_0 + w_1 \boldsymbol{d}, \\
    \boldsymbol{r}_2 = \boldsymbol{r}_0 - w_2 \boldsymbol{d},
    \end{split}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{r}_0\)</span> is the center of the educt molecule. By
default <span class="math notranslate nohighlight">\(w_1 = w_2 = 0.5\)</span>. However, for different sized educts one
may choose <span class="math notranslate nohighlight">\(w_1\)</span> and <span class="math notranslate nohighlight">\(w_2\)</span> proportional to the molecules
diffusion coefficient or the diffusion length constant. If the educt and
product molecules are surface molecules, the procedure is equivalent
except that the direction vector is sampled from a disc on the mesh
surface instead of from a sphere. If the educt is a surface molecule but
the product a volume molecule, in addition to the sphere radius, the
direction needs to be defined, .i.e whether the product is placed inside
or outside the compartment. In both cases, the direction vector is not
sampled from the full rotation space but only within the half-sphere cut
by the triangle plane. Also, whenever a mesh compartment is present in
the simulation, a ray tracing algorithm is used to resolve any
collisions of the products’ direction vectors with the mesh.</p>
<p><em>production reactions</em>: In addition to the standard fission reaction,
PyRID supports reactions with more than two products, which are here
called production reactions, because an educt molecule “produces” a
number of product molecules. This type of reaction can, e.g., be used to
simulate the influx of ions into a compartment via an ion channel. The
procedure by which the reaction is executed is very similar to the
fission reaction. However, here, the educt molecule is preserved but may
change its type. Also, for each product molecule, a separate direction
vector within a sphere of radius <span class="math notranslate nohighlight">\(R_{prod}\)</span> is sampled. Collisions
with the mesh are handled as before, however, collisions between the
product molecules are not resolved.</p>
<p><em>release reaction</em>: PyRID also allows for a fission type reaction to be
defined on particles, which is called a release reaction. Release
reactions are limited to one particle and one molecule product. When a
release reaction is executed, the particle is converted to the product
particle type while releasing a product molecule either into the
simulation volume or the surface of a mesh compartment. The latter is
only possible if the rigid bead molecule the educt particle belongs to
is also a surface molecule. Release reactions can, e.g., be used to
simulate the release of a ligand from a specific binding site of a rigid
bead molecule. The release reaction is introduced as the inverse of the
particle absorption reaction (see next section on bi-molecular
reactions).</p>
<figure class="align-default" id="fig-reaction-overview-um">
<a class="reference internal image-reference" href="../../_images/Reactions_Overview_UM.png"><img alt="../../_images/Reactions_Overview_UM.png" src="../../_images/Reactions_Overview_UM.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18 </span><span class="caption-text"><strong>Unimolecular reactions.</strong> Unimolecular reactions can be either
defined on a particle or on a molecule type. Their exist in total
three different unimolecular reaction type categories: fission,
conversion and decay. For details see text.</span><a class="headerlink" href="#fig-reaction-overview-um" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="bi-molecular-reactions">
<h3>Bi-molecular reactions<a class="headerlink" href="#bi-molecular-reactions" title="Permalink to this heading"></a></h3>
<p>Bi-molecular reactions cannot be evaluated the same way as uni-molecular
reactions since we cannot sample from the corresponding probability
space as we have done for the uni-molecular reactions, because we do not
know when two molecules meet in advance. Here, we use a reaction scheme
introduced by <span id="id47">Doi [<a class="reference internal" href="../../References.html#id29" title="M Doi. Stochastic theory of diffusion-controlled reaction. Journal of Physics A: Mathematical and General, 9(9):1479–1495, sep 1976. doi:10.1088/0305-4470/9/9/009.">24</a>]</span>, which is also used in the
Brownian dynamics simulation tool ReaDDy
<span id="id48">[<a class="reference internal" href="../../References.html#id4" title="Moritz Hoffmann, Christoph Fröhner, and Frank Noé. ReaDDy 2: fast and flexible software framework for interacting-particle reaction dynamics. PLOS Computational Biology, 15(2):e1006830, feb 2019. doi:10.1371/journal.pcbi.1006830.">23</a>, <a class="reference internal" href="../../References.html#id58" title="Johannes Schöneberg and Frank Noé. ReaDDy - a software for particle-based reaction-diffusion dynamics in crowded cellular environments. PLoS ONE, 8(9):e74261, sep 2013. doi:10.1371/journal.pone.0074261.">86</a>]</span>. In this scheme, two
molecules can only react if the inter-molecular distance
<span class="math notranslate nohighlight">\(|\boldsymbol{r}_{ij}|\)</span> is below a reaction radius
<span class="math notranslate nohighlight">\(R_{react}\)</span>. The probability of having at least one reaction is
then given by</p>
<div class="math notranslate nohighlight">
\[p = 1-\exp\Big(-\sum_i^n k_i \Delta t \Big),\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of reaction paths. Here, we assume that
the time step <span class="math notranslate nohighlight">\(\Delta t\)</span> is so small that the molecule can only
undergo one reaction. As such, the accuracy of the simulation strongly
depends on the proportion between the reaction rate and the time step
<span class="math notranslate nohighlight">\(\Delta t\)</span>. If <span class="math notranslate nohighlight">\(k_t \cdot \Delta t&gt;0.1\)</span>, PyRID will print
out a warning. As for uni-molecular reactions, each bi-molecular
reaction can contain several reaction paths, each of which can be of a
different bi-molecular reaction type. PyRID supports the following
bi-molecular reactions:</p>
<ol class="arabic simple">
<li><p>fusion reactions,</p>
<ul class="simple">
<li><p>molecule fusion,</p></li>
<li><p>particle-molecule absorption,</p></li>
</ul>
</li>
<li><p>enzymatic reactions (defined on molecules or particles),</p></li>
<li><p>binding reactions</p></li>
</ol>
<figure class="align-default" id="fig-reaction-overview-bm">
<a class="reference internal image-reference" href="../../_images/Reactions_Overview_BM.png"><img alt="../../_images/Reactions_Overview_BM.png" src="../../_images/Reactions_Overview_BM.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 19 </span><span class="caption-text"><strong>Bimolecular reactions.</strong> Bimolecular reactions can be either
defined on a particle or on a molecule type. Their exist in total
three different bimolecular reaction type categories: enzymatic,
fusion and binding. For details see text.</span><a class="headerlink" href="#fig-reaction-overview-bm" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p><em>Molecule fusion</em> reactions are defined on molecule pairs. The product
molecule is always placed relative to the position of the first educt.
Thereby, in PyRID, the order in which the educts of a reaction are set
is important. For example, for a fusion reaction <span class="math notranslate nohighlight">\(\ce{A + B -&gt; C}\)</span>
the product is placed at
<span class="math notranslate nohighlight">\(\boldsymbol{R}_A + \omega \Delta \boldsymbol{R}\)</span>, where
<span class="math notranslate nohighlight">\(\boldsymbol{R}_A\)</span> is the origin of molecule <span class="math notranslate nohighlight">\(A\)</span>,
<span class="math notranslate nohighlight">\(\Delta \boldsymbol{R}\)</span> is the distance vector between <span class="math notranslate nohighlight">\(A\)</span>
and <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> is a weight factor. For a
<span class="math notranslate nohighlight">\(\ce{B + A -&gt; C}\)</span>, the product is placed at
<span class="math notranslate nohighlight">\(\boldsymbol{R}_B + \omega \Delta \boldsymbol{R}\)</span>. By default,
<span class="math notranslate nohighlight">\(\omega = 0.5\)</span> such that the product is placed in the middle
between the educt and the order does not matter. However, for
<span class="math notranslate nohighlight">\(\omega \neq 0.5\)</span>, the order in which the educts have been set
determines where the product is placed.</p>
<p>In addition to the fusion reaction, PyRID offers the <em>particle-molecule
absorption reaction</em>, which is also a reaction of the fusion type.
However, here a molecule is absorbed by the bead/particle of another
molecule. The molecule is thereby removed from the simulation and the
absorbing particle is converted to a different type.</p>
<p><em>Binding reactions</em> are defined between two particle/bead types and
handled similar to fusion and enzymatic reactions except that, if the
reaction was successful, an energy potential between the two educt
particles is introduced such that these interact with each other. Upon
binding, the beads can change their respective type. Also, a bead can
only be bound to one partner particle at a time. Bonds can be either
persistent or breakable. In the latter case, the bond is removed as soon
as the inter-particle distance crosses an unbinding threshold.
Similarly, unbinding reactions can be introduced by means of a
conversion reaction as bonds are removed if a particle or the
corresponding rigid bead molecule are converted to a different type.</p>
<section id="reactions-between-surface-molecules">
<h4>Reactions between surface molecules<a class="headerlink" href="#reactions-between-surface-molecules" title="Permalink to this heading"></a></h4>
<p>As for volume molecules, molecules that reside on the surface/in the
membrane of a compartment react with each other if the inter-particle
distance is below the reaction radius. However, PyRID only computes the
euclidean distance between particles. Therefore, however, surface
reactions are only accurate if the local surface curvature is large
compared to the reaction radius. Accurate calculation of the geodesic
distance on mesh surfaces is computationally very expensive. Algorithms
that allow for relatively fast approximations of geodesic distances and
shortest paths such as the Dijkstra’s algorithm often only provide good
approximations for point far away from the source. Therefore, the
benefit of implementing such algorithms is questionable as reaction
radii are on the order of the molecule size and thereby usually small
compared to the mesh size. However, much progress has been made in this
field <span id="id49">[<a class="reference internal" href="../../References.html#id59" title="Konrad Polthier and Markus Schmies. Straightest geodesics on polyhedral surfaces. In ACM SIGGRAPH 2006 Courses on - SIGGRAPH \textquotesingle 06. ACM Press, 2006. doi:10.1145/1185657.1185664.">87</a>, <a class="reference internal" href="../../References.html#id61" title="Keenan Crane, Clarisse Weischedel, and Max Wardetzky. The heat method for distance computation. Communications of the ACM, 60(11):90–99, oct 2017. doi:10.1145/3131280.">88</a>, <a class="reference internal" href="../../References.html#id60" title="P. Trettner, D. Bommes, and L. Kobbelt. Geodesic distance computation via virtual source propagation. Computer Graphics Forum, 40(5):247–260, aug 2021. doi:10.1111/cgf.14371.">89</a>]</span>.</p>
</section>
</section>
</section>
<section id="potentials">
<h2>Potentials<a class="headerlink" href="#potentials" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/potentials_util.html#module-pyrid.system.potentials_util" title="pyrid.system.potentials_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.potentials_util</span></code></a></p>
</div>
</details><p>PyRID supports any pairwise, short ranged interaction potential and
external potentials. The force is given by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{F}_i = \nabla_i \left( \sum U_{ext}(\boldsymbol{r}_i) + \sum_{i \neq j} U_{pair}(\boldsymbol{r}_i, \boldsymbol{r}_j) \right)\]</div>
<p>PyRID comes with a selection of pairwise interaction potentials. PyRID
does not support methods such as Ewald summation and pair interaction
potentials need to be short ranged, i.e., they need to have a cutoff
distance.</p>
<p>In the following I list the functions currently implemented in PyRID.
However, any short ranged, pair-wise interaction potential can be easily
added using python.</p>
<section id="weak-piecewise-harmonic-potential">
<h3>Weak piecewise harmonic potential<a class="headerlink" href="#weak-piecewise-harmonic-potential" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/potentials_util.html#pyrid.system.potentials_util.piecewise_harmonic" title="pyrid.system.potentials_util.piecewise_harmonic"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.potentials_util.piecewise_harmonic</span></code></a></p>
</div>
</details><p>The very same interaction potential is also used in ReaDDy
<span id="id50">[<a class="reference internal" href="../../References.html#id4" title="Moritz Hoffmann, Christoph Fröhner, and Frank Noé. ReaDDy 2: fast and flexible software framework for interacting-particle reaction dynamics. PLOS Computational Biology, 15(2):e1006830, feb 2019. doi:10.1371/journal.pcbi.1006830.">23</a>]</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-weak-piecewise-harmonic">
<span class="eqno">(50)<a class="headerlink" href="#equation-eq-weak-piecewise-harmonic" title="Permalink to this equation"></a></span>\[\begin{split}\begin{split}U_{ha}(r)
=
\begin{cases}
    \frac{1}{2}k(r-(d_1+d_2))^2-h,&amp; \text{if } r&lt;(d_1+d_2), \\
    \frac{h}{2}(\frac{r_c-(d_1+d_2)}{2})^{-2}(r-(d_1+d_2))^2-h,&amp; \text{if } d \le r &lt; d + \frac{r_c-(d_1+d_2)}{2}, \\
    -\frac{h}{2}(\frac{r_c-(d_1+d_2)}{2})^{-2}(r-r_c)^2,&amp; \text{if } d + \frac{r_c-(d_1+d_2)}{2} \le r &lt; r_c, \\
    0,              &amp; \text{otherwise}
\end{cases}\end{split}\end{split}\]</div>
</section>
<section id="harmonic-repulsion-potential">
<h3>Harmonic repulsion potential<a class="headerlink" href="#harmonic-repulsion-potential" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/potentials_util.html#pyrid.system.potentials_util.harmonic_repulsion" title="pyrid.system.potentials_util.harmonic_repulsion"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.potentials_util.harmonic_repulsion</span></code></a></p>
</div>
</details><p>The very same interaction potential is also used in ReaDDy
<span id="id51">[<a class="reference internal" href="../../References.html#id4" title="Moritz Hoffmann, Christoph Fröhner, and Frank Noé. ReaDDy 2: fast and flexible software framework for interacting-particle reaction dynamics. PLOS Computational Biology, 15(2):e1006830, feb 2019. doi:10.1371/journal.pcbi.1006830.">23</a>]</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-harmonic-repulsion">
<span class="eqno">(51)<a class="headerlink" href="#equation-eq-harmonic-repulsion" title="Permalink to this equation"></a></span>\[U(r)
=
\Biggl \lbrace
{
\frac{\kappa}{2}(r-\sigma)^2,\text{ if }
    { r \leq \sigma }
\atop
0, \text{ otherwise },
}\]</div>
</section>
<section id="continuous-square-well-csw-potential">
<h3>Continuous Square-Well (CSW) potential<a class="headerlink" href="#continuous-square-well-csw-potential" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/potentials_util.html#pyrid.system.potentials_util.CSW" title="pyrid.system.potentials_util.CSW"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.potentials_util.CSW</span></code></a></p>
</div>
</details><p>The Continuous Square-Well (CSW) potential has been introduced in
<span id="id52">[<a class="reference internal" href="../../References.html#id5" title="J. R. Espinosa, C. Vega, and E. Sanz. The mold integration method for the calculation of the crystal-fluid interfacial free energy from simulations. The Journal of Chemical Physics, 141(13):134709, oct 2014. doi:10.1063/1.4896621.">29</a>]</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-csw">
<span class="eqno">(52)<a class="headerlink" href="#equation-eq-csw" title="Permalink to this equation"></a></span>\[U_{CSW}(r) = - \frac{\epsilon_{CSW}}{2} \Big[1 - \tanh\Big(\frac{r-r_w}{\alpha}\Big)\Big].\]</div>
</section>
<section id="pseudo-hard-sphere-phs-potential">
<h3>Pseudo Hard Sphere (PHS) potential<a class="headerlink" href="#pseudo-hard-sphere-phs-potential" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/potentials_util.html#pyrid.system.potentials_util.PHS" title="pyrid.system.potentials_util.PHS"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.potentials_util.PHS</span></code></a></p>
</div>
</details><p>The Pseudo Hard Sphere (PHS) potential has been introduced in
<span id="id53">[<a class="reference internal" href="../../References.html#id3" title="J. Jover, A. J. Haslam, A. Galindo, G. Jackson, and E. A. Müller. Pseudo hard-sphere potential for use in continuous molecular-dynamics simulation of spherical and chain molecules. The Journal of Chemical Physics, 137(14):144505, oct 2012. doi:10.1063/1.4754275.">31</a>]</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-phs">
<span class="eqno">(53)<a class="headerlink" href="#equation-eq-phs" title="Permalink to this equation"></a></span>\[U_{HS}
=
\Biggl \lbrace
{
\lambda_r (\frac{\lambda_r}{\lambda_a})^{\lambda_a} \epsilon_R [(\frac{\sigma}{r})^{\lambda_r}-(\frac{\sigma}{r})^{\lambda_a}]+\epsilon_R,\text{ if }
    { r &lt; (\frac{\lambda_r}{\lambda_a}) \sigma }
\atop
0, \text{ if }
    { r &lt; (\frac{\lambda_r}{\lambda_a}) \sigma },
}\]</div>
</section>
</section>
<section id="observables">
<h2>Observables<a class="headerlink" href="#observables" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.observables.observables_util</span></code>
<a class="reference internal" href="../Developer%20API/observables/observables_util.html#pyrid.observables.observables_util.Observables" title="pyrid.observables.observables_util.Observables"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.observables.observables_util.Observables</span></code></a></p>
</div>
</details><p>PyRID can sample several different system properties:</p>
<ol class="arabic simple">
<li><p>Energy</p></li>
<li><p>Pressure</p></li>
<li><p>Virial</p></li>
<li><p>Virial tensor</p></li>
<li><p>Volume</p></li>
<li><p>Molecule number</p></li>
<li><p>Bonds</p></li>
<li><p>Reactions</p></li>
<li><p>Position</p></li>
<li><p>Orientation</p></li>
<li><p>Force</p></li>
<li><p>Torque</p></li>
<li><p>Radial distribution function</p></li>
</ol>
<p>Each observable (except the volume) is sampled per molecule type or
molecule/particle pair in the case of bimolecular reactions and bonds.
In addition, values can be sampled in a step-wise or binned fashion.
Binning is especially useful when sampling reactions as one is usually
interested in the total number of reactions that occurred with a time
interval and not in the number of reactions that occurred at a specific
point in time. In the following I briefly describe how the radial
distribution function and the pressure are calculated in PyRID.</p>
<section id="radial-distribution-function">
<h3>Radial distribution function<a class="headerlink" href="#radial-distribution-function" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/observables/observables_util.html#pyrid.observables.observables_util.Observables.observe_rdf" title="pyrid.observables.observables_util.Observables.observe_rdf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.observables.observables_util.Observables.observe_rdf</span></code></a>
<a class="reference internal" href="../Developer%20API/evaluation/rdf_util.html#module-pyrid.evaluation.rdf_util" title="pyrid.evaluation.rdf_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.evaluation.rdf_util</span></code></a>
<a class="reference internal" href="../Developer%20API/evaluation/rdf_util.html#pyrid.evaluation.rdf_util.radial_distr_function" title="pyrid.evaluation.rdf_util.radial_distr_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.evaluation.rdf_util.radial_distr_function</span></code></a></p>
</div>
</details><p>The radial distribution function is given by</p>
<div class="math notranslate nohighlight">
\[g(\boldsymbol{r}) = \frac{V_{box}}{N_i N_j} \left\langle \sum_{i \neq j} \delta(\boldsymbol{r}-(\boldsymbol{r}_i-\boldsymbol{r}_j)) \right\rangle = \frac{V_{box}}{N_i N_j} \frac{1}{V(\boldsymbol{r})} \sum_{i \neq j} \delta(\boldsymbol{r}-(\boldsymbol{r}_i-\boldsymbol{r}_j))\]</div>
<p>where <span class="math notranslate nohighlight">\(V(\boldsymbol{r}) = \frac{4}{3} \pi (r-\Delta r)^3\)</span> with
<span class="math notranslate nohighlight">\(\Delta r\)</span> being the sampling bin size. <span class="math notranslate nohighlight">\(V_{box}\)</span> is the
volume of the simulation box and <span class="math notranslate nohighlight">\(N_i\)</span> and <span class="math notranslate nohighlight">\(N_j\)</span> are the
total number of molecule types <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> respectively.</p>
</section>
<section id="pressure">
<h3>Pressure<a class="headerlink" href="#pressure" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/run.html#pyrid.run.update_pressure" title="pyrid.run.update_pressure"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.run.update_pressure</span></code></a></p>
</div>
</details><p>The pressure can be calculated from the virial or the the viral tensor.
However, when calculating the pressure for a system of rigid bodies/
rigid bead molecules, we need to be careful how to calculate the virial
tensor. Taking the inter-particle distances will result in the wrong
pressure. Instead, one needs to calculate the molecular virial
<span id="id54">[<a class="reference internal" href="../../References.html#id25" title="Jens Glaser, Xun Zha, Joshua A. Anderson, Sharon C. Glotzer, and Alex Travesset. Pressure in rigid body molecular dynamics. Computational Materials Science, 173:109430, feb 2020. doi:10.1016/j.commatsci.2019.109430.">35</a>]</span>, by taking the pairwise distance between
the center of diffusion of the respective molecule pairs:</p>
<div class="math notranslate nohighlight">
\[P_{mol} = P_{mol}^{kin} + \frac{1}{6 V} \sum_{i=1}^{N} \sum_{j \neq}^{N} \langle \boldsymbol{F}_{ij} \cdot (\boldsymbol{R}_i - \boldsymbol{R}_j) \rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(V\)</span> is the total volume of the simulation box,
<span class="math notranslate nohighlight">\(\boldsymbol{F}_{ij}\)</span> is the force on particle i exerted by
particle j and <span class="math notranslate nohighlight">\(\boldsymbol{R}_{i}, \boldsymbol{R}_{j}\)</span> are the
center of diffusion of the rigid body molecules, not the center of mass
of particles i and j! In Brownian dynamics simulations,
<span class="math notranslate nohighlight">\(P_{mol}^{kin} = N_{mol} k_B T\)</span>, where <span class="math notranslate nohighlight">\(N_{mol}\)</span> is the
number of molecules. Also, the origin of molecules is represented by the
center of diffusion around which the molecule rotates about, which is
not the center of mass <span id="id55">[<a class="reference internal" href="../../References.html#id19" title="Steven Harvey and Jose Garcia de la Torre. Coordinate systems for modeling the hydrodynamic resistance and diffusion coefficients of irregularly shaped rigid macromolecules. Macromolecules, 13(4):960–964, jul 1980. doi:10.1021/ma60076a037.">15</a>]</span>. The net
frictional force and torque act through the center of diffusion. This is
because when doing Brownian dynamics (and equaly for Langevin dynamics),
we do account for the surrounding fluid. Different parts of the molecule
will therefore interact with each other via hydrodynamic
interactions/coupling. As a result, the center of the molecule (around
which the molecule rotates in response to external forces) is not the
same as the center of mass, which assumes no such interactions (the
molecule sites in empty space). However, for symmetric molecules, the
center of mass and the center of diffusion are the same.</p>
</section>
</section>
<section id="berendsen-barostat">
<h2>Berendsen barostat<a class="headerlink" href="#berendsen-barostat" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/system_util.html#pyrid.system.system_util.System.add_barostat_berendsen" title="pyrid.system.system_util.System.add_barostat_berendsen"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.system_util.System.add_barostat_berendsen</span></code></a></p>
</div>
</details><p>It is sometimes desirable to be able to do simulations in the NPT
ensemble, e.g., in preparation steps to release the system from
stresses. This can become necessary, e.g. when computing inter-facial
properties of fluids or computing phase diagrams via direct coexistence
methods <span id="id56">[<a class="reference internal" href="../../References.html#id2" title="Jorge R. Espinosa, Adiran Garaizar, Carlos Vega, Daan Frenkel, and Rosana Collepardo-Guevara. Breakdown of the law of rectilinear diameter and related surprises in the liquid-vapor coexistence in systems of patchy particles. The Journal of Chemical Physics, 150(22):224510, jun 2019. doi:10.1063/1.5098551.">30</a>, <a class="reference internal" href="../../References.html#id24" title="Erich A. Muller, Åsmund Ervik, and Andrés Mej\'ıa. A guide to computing interfacial properties of fluids from molecular simulations [article v1.0]. Living Journal of Computational Molecular Science, 2020. doi:10.33011/livecoms.2.1.21385.">32</a>, <a class="reference internal" href="../../References.html#id28" title="Jorge R. Espinosa, Jerelle A. Joseph, Ignacio Sanchez-Burgos, Adiran Garaizar, Daan Frenkel, and Rosana Collepardo-Guevara. Liquid network connectivity regulates the stability and composition of biomolecular condensates with many components. Proceedings of the National Academy of Sciences, 117(24):13238–13247, jun 2020. doi:10.1073/pnas.1917569117.">90</a>]</span>. The
Berendsen barostat <span id="id57">[<a class="reference internal" href="../../References.html#id66" title="H. J. C. Berendsen, J. P. M. Postma, W. F. van Gunsteren, A. DiNola, and J. R. Haak. Molecular dynamics with coupling to an external bath. The Journal of Chemical Physics, 81(8):3684–3690, oct 1984. doi:10.1063/1.448118.">91</a>]</span> is simple to
implement and results in the correct target density of the system,
however, it does not sample from the correct statistical ensemble
distribution as pressure fluctuations are usually too small. By scaling
the inter-particle distances, the Berendsen barostat changes the virial
and thereby the system pressure. Per time step, the molecule coordinates
and simulation box length are scaled by a factor <span class="math notranslate nohighlight">\(\mu\)</span> that is
given by:</p>
<div class="math notranslate nohighlight">
\[\mu = (1-\Delta t/\tau_P (P_0-P))^{1/3},\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau_P\)</span> is the coupling time constant, <span class="math notranslate nohighlight">\(P_0\)</span> the
target pressure. The above equation applies to an isotropic system. For
a anisotropic system the equation can be generalized by substituting P
with the pressure tensor. In the case of a rectangular simulation box,
all tensor remain diagonal and application of the anisotropic barostat
is trivial.</p>
</section>
<section id="distribution-of-molecules">
<h2>Distribution of molecules<a class="headerlink" href="#distribution-of-molecules" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#module-pyrid.system.distribute_vol_util" title="pyrid.system.distribute_vol_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#module-pyrid.system.distribute_surface_util" title="pyrid.system.distribute_surface_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util</span></code></a></p>
</div>
</details><section id="id58">
<h3>Volume molecules<a class="headerlink" href="#id58" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#module-pyrid.system.distribute_vol_util" title="pyrid.system.distribute_vol_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.monte_carlo_distribution_3D" title="pyrid.system.distribute_vol_util.monte_carlo_distribution_3D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.monte_carlo_distribution_3D</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.normal" title="pyrid.system.distribute_vol_util.normal"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.normal</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.pds" title="pyrid.system.distribute_vol_util.pds"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.pds</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.pds_uniform" title="pyrid.system.distribute_vol_util.pds_uniform"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.pds_uniform</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.poisson_disc_sampling" title="pyrid.system.distribute_vol_util.poisson_disc_sampling"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.poisson_disc_sampling</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_vol_util.html#pyrid.system.distribute_vol_util.poisson_disc_sampling_uniform" title="pyrid.system.distribute_vol_util.poisson_disc_sampling_uniform"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_vol_util.poisson_disc_sampling_uniform</span></code></a></p>
</div>
</details><p>The distribution of molecules in the simulation volume becomes a special
problem when we have mesh compartments and account for the excluded
volume of the molecules. A standard approach from molecular dynamics
first loosely distributes the molecules in the simulation box and then
shrinks the simulation volume until a target density is reached. This
approach could be transferred to a system with mesh compartments.
However, here, we might also care about the compartment size. As such,
we would need to choose a larger than target compartment size and shrink
it until we reach the target size. If the density is too large, we may
randomly delete molecules until the target density is also reached. A
second approach would be to utilize the Metropolis Monte Carlo method
<span id="id59">[<a class="reference internal" href="../../References.html#id26" title="Michael P. Allen and Dominic J. Tildesley. Computer Simulation of Liquids. Oxford University Press, nov 2017. doi:10.1093/oso/9780198803195.001.0001.">3</a>]</span> to distribute the molecules. However,
this approach is more time-consuming. A third approach, which is the one
we use in PyRID, uses a so-called Poisson-Disc sampling algorithm
<span id="id60">[<a class="reference internal" href="../../References.html#id36" title="Robert Bridson. Fast poisson disk sampling in arbitrary dimensions. In ACM SIGGRAPH 2007 sketches on - SIGGRAPH \textquotesingle 07. ACM Press, 2007. doi:10.1145/1278780.1278807.">27</a>]</span>. This approach has the benefit of being
computationally efficient and relatively simple to implement. It,
however, has the disadvantage of not reaching densities above 30% and is
only well suited for approximately spherical molecules. To distribute
highly aspherical molecules, currently, the only useful method that
works well with PyRID is to distribute the molecules using Monte-Carlo
sampling and then resolve overlaps via a soft repulsive interaction
potential. If no mesh compartments are used, one may also use the
Berendsen barostat at high pressure to drive the system to a high
density state. The Poison-disc sampling algorithm consists of 3 steps.
1) A grid is initialized, where the cell size is set to
<span class="math notranslate nohighlight">\(r/\sqrt{3}\)</span>. 2) A sample point is created and inserted into a
list of active elements. 3) While the active list is not empty, new
random points around the annulus (r-2r) of the active sample points are
created. If no other sample points exist within the radius r, the new
sample point is accepted and inserted into the grid and the active list.
If, after k trials, no new sample point is found, the active sample
point is removed from the active list. For PyRID, this algorithm has
been extended to account for polydisperse particle distributions.</p>
</section>
<section id="surface-molecules-1">
<span id="id61"></span><h3>Surface molecules<a class="headerlink" href="#surface-molecules-1" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#module-pyrid.system.distribute_surface_util" title="pyrid.system.distribute_surface_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.monte_carlo_distribution_2D" title="pyrid.system.distribute_surface_util.monte_carlo_distribution_2D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.monte_carlo_distribution_2D</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.normal" title="pyrid.system.distribute_surface_util.normal"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.normal</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.pds" title="pyrid.system.distribute_surface_util.pds"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.pds</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.point_on_sphere" title="pyrid.system.distribute_surface_util.point_on_sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.point_on_sphere</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.poisson_disc_sampling_2D" title="pyrid.system.distribute_surface_util.poisson_disc_sampling_2D"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.poisson_disc_sampling_2D</span></code></a>
<a class="reference internal" href="../Developer%20API/system/distribute_surface_util.html#pyrid.system.distribute_surface_util.random_point_in_triangle" title="pyrid.system.distribute_surface_util.random_point_in_triangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.distribute_surface_util.random_point_in_triangle</span></code></a></p>
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/math/transform_util.html#pyrid.math.transform_util.orthogonal_vector" title="pyrid.math.transform_util.orthogonal_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.math.transform_util.orthogonal_vector</span></code></a></p>
</div>
</details><p>The distribution of molecules on the surface of a mesh compartment is a
little more involved. Here, we utilize an algorithm introduced by
<span id="id62">Corsini <em>et al.</em> [<a class="reference internal" href="../../References.html#id37" title="M. Corsini, P. Cignoni, and R. Scopigno. Efficient and flexible sampling with blue noise properties of triangular meshes. IEEE Transactions on Visualization and Computer Graphics, 18(6):914–924, jun 2012. doi:10.1109/tvcg.2012.34.">25</a>]</span>:</p>
<ol class="arabic simple">
<li><p>Generate a sample pool S by uniformly distributing points on the mesh
surface.</p></li>
<li><p>Divide space into cells and count the number of samples in each cell.</p></li>
<li><p>Randomly select a cell weighted by the number of active samples in
each cell (active sample: sample that is not yet occupied or
deleted).</p></li>
<li><p>Randomly select a sample from the selected cell.</p></li>
<li><p>Randomly choose a particle type of radius <span class="math notranslate nohighlight">\(R_i\)</span> (weighted by
the relative number of each type we want to distribute).</p></li>
<li><p>Check whether the distance of the selected sample to the neighboring
samples that are already occupied is larger or equal to Ri+Rj.</p></li>
<li><p>If True, accept the sample and add the molecule type and position to
an occupied sample list. Next, delete all other samples within radius
Ri, as these won’t ever become occupied anyway.</p></li>
<li><p>Update the number count of samples for the current cell.</p></li>
<li><p>While the desired number of molecules is not reached, return to 3.
However, set a maximum number of trials.</p></li>
<li><p>If there are no active samples left before we reach the desired
molecule number and the maximum number of trials, generate a new
sample pool.</p></li>
</ol>
<p>PyRID also allows the user to assign individual mesh triangles to a
group and thereby define surface regions on which to distribute
molecules. Example results for the distribution of volume and surface
molecules using the above described methods are shown in Fig.
<a class="reference external" href="#fig:Poisson-Disc-Sampling">1.6</a>.</p>
<figure class="align-default" id="fig-poisson-disc-sampling">
<a class="reference internal image-reference" href="../../_images/Sphere_Packing.png"><img alt="../../_images/Sphere_Packing.png" src="../../_images/Sphere_Packing.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 20 </span><span class="caption-text"><strong>Poisson Disc Sampling of polydisperse spheres.</strong> <strong>(A)</strong> Example
distribution for three different sized particle types confined to the
volume of a mesh compartment . <strong>(B)</strong> Poisson Disc sampling for
surface molecules.<strong>(C)</strong> Poisson Disc sampling for surface
molecules but restricted to a surface region that is defined by a
triangle face group.</span><a class="headerlink" href="#fig-poisson-disc-sampling" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="fast-algorithms-for-brownian-dynamics-of-reacting-and-interacting-particles">
<h2>Fast algorithms for Brownian dynamics of reacting and interacting particles<a class="headerlink" href="#fast-algorithms-for-brownian-dynamics-of-reacting-and-interacting-particles" title="Permalink to this heading"></a></h2>
<p>PyRID is written entirely in the programming language python. To make
the simulations run efficiently, PyRID heavily relies on jit compilation
using Numba. In addition, PyRID uses a data-oriented design and specific
dynamic array data structures to keep track of molecules and their
reactions efficiently. For this important part of the PyRID
implementation to not remain elusive, I will introduce the main data
structures that make PyRID run efficiently in this section. A very nice
introduction/overview to the kind of data structures used here has been
written by Niklas Gray <a class="footnote-reference brackets" href="#id68" id="id63" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<section id="dynamic-arrays-in-pyrid">
<h3>Dynamic arrays in PyRID<a class="headerlink" href="#dynamic-arrays-in-pyrid" title="Permalink to this heading"></a></h3>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.dynamic_array_util</span></code></p>
</div>
</details><p>In PyRID, molecules and particles constantly enter or leave the system
due to reactions and other events. Therefore, we need a data structure
that can efficiently handle this constant change in the number of
objects we need to keep track of in our simulation. The same holds true
for the molecular reactions occurring at each time step. These need to
be listed and evaluated efficiently. Fortunately, variants of dynamic
array data structures are tailored for such tasks, of which we use two
kinds, the tightly packed dynamic array and the dynamic array with
holes.</p>
<section id="the-tightly-packed-dynamic-array-dense-array">
<h4>The tightly packed dynamic array (dense array)<a class="headerlink" href="#the-tightly-packed-dynamic-array-dense-array" title="Permalink to this heading"></a></h4>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/data_structures/dynamic_array_util.html#pyrid.data_structures.dynamic_array_util.DenseArray" title="pyrid.data_structures.dynamic_array_util.DenseArray"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.dynamic_array_util.DenseArray</span></code></a></p>
</div>
</details><p>A tightly packed dynamic array is a dynamic array (similar to lists in
python or vectors in C++) where elements can be quickly deleted via a
pop and swap mechanism (Fig. <a class="reference external" href="#fig:DynamicArray_Molecules">1.7</a>). The
problem with standard numpy arrays but also lists and C++ vectors is
that deletion of elements is very expensive. For example, if we want to
delete an element at index m of a numpy array of size n, numpy would
create a new array that is one element smaller and copies all the data
from the original array to the new array. Also, if we want to increase
the size of a numpy array by appending an element, again, a new array
will need to be created, and all data needs to be copied. This is
extremely computationally expensive. One way to create a dynamic array
(and python lists work in that way) is to not increase the array size
each time an element is added but increase the array size by some
multiplicative factor (usually 2). This consumes more memory but saves
us from creating new arrays all the time. Now we simply need to keep
track of the number of elements in the array (the length of the array)
and the actual capacity, which can be much larger. One straightforward
method to delete elements from the array is just to take the last
element of the array and copy its data to wherever we want to delete an
element (swapping). Next, we pop out the last element by decreasing the
array length by 1. We call this type of array a ‘tightly packed array’
because it keeps the array tightly packed. One issue with this method is
that elements move around. Thereby, to find an element by its original
insertion index, we need to keep track of where elements move. One can
easily solve this issue by keeping a second array that saves for each
index the current location in the tightly packed array.</p>
</section>
<section id="the-dynamic-array-with-holes">
<h4>The dynamic array with holes<a class="headerlink" href="#the-dynamic-array-with-holes" title="Permalink to this heading"></a></h4>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/data_structures/dynamic_array_util.html#pyrid.data_structures.dynamic_array_util.HolesArray" title="pyrid.data_structures.dynamic_array_util.HolesArray"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.dynamic_array_util.HolesArray</span></code></a></p>
</div>
</details><p>To store molecules and particles, we use a dynamic array with holes
(Fig. <a class="reference external" href="#fig:DynamicArray_Molecules">1.7</a>). A dynamic array with holes
is an array where elements can be quickly deleted by creating ‘holes’ in
the array. These holes are tracked via a free linked list. The array
with holes has the benefit over the ‘tightly packed array’ that elements
keep their original index because they are not shifted/swapped at any
point due to deletion of other elements. This makes accessing elements
by index a bit faster compared to the other approach. However, if the
number of holes is large, i.e. the array is sparse, this approach is not
very cache friendly. Also, iterating over the elements in the array
becomes more complex because we need to skip the holes. Therefore, we
add a second array, which is a tightly packed array, that saves the
indices of all the occupied slots in the array with holes
(alternatively, we could add another linked list that connects all
occupied slots). We can then iterate over all elements in the holes
array by iterating over the tightly packed array. Keep in mind, however,
that the order is not preserved in the tightly packed array, since,
whenever we delete an element from the holes array, we also need to
delete this element from the dense array by the pop and swap mechanism.
As such, this method does not work well if we need to iterate over a
sorted array. In that case, one should use a free linked list approach
for iteration. As with the tightly packed dynamic array, the array size
is increased by a multiplicative factor of 2 as soon as the capacity
limit is reached.</p>
<figure class="align-default" id="fig-dynamicarray-molecules">
<a class="reference internal image-reference" href="../../_images/DynamicArrays.png"><img alt="../../_images/DynamicArrays.png" src="../../_images/DynamicArrays.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 21 </span><span class="caption-text"><strong>Dynamic arrays.</strong> <strong>(A)</strong> Tightly packed dynamic array. A tightly
packed dynamic array uses a pop and swap mechanism to delete single
elements. New elements are appended. Thereby, however, elements
change their position. To find elements, a second, sparsely packed
dynamic array is introduced that keeps track of the array index of
each element. <strong>(B)</strong> In sparsely packed dynamic arrays, elements are
deleted by creating holes. Holes are kept track of by a free linked
list. Sparsely packed dynamic arrays have the benefit of keeping the
position of each element inside the array fixed, which makes finding
elements easy. However, this comes at the expense of more memory
usage. Also, iteration over a sparse dynamic array is not straight
forward as we must skip the holes in the array. Their exist different
methods to iterate over such an array. In PyRID, a second, densely
packed array is introduced that keeps the indices of all occupied
slots. However, in order to be able to delete an element, we now also
need third, sparse array, that keeps track of the element indices in
the densely packed array.</span><a class="headerlink" href="#fig-dynamicarray-molecules" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="dynamic-arrays-used-for-reaction-handling">
<h4>Dynamic arrays used for reaction handling<a class="headerlink" href="#dynamic-arrays-used-for-reaction-handling" title="Permalink to this heading"></a></h4>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/data_structures/dynamic_array_util.html#pyrid.data_structures.dynamic_array_util.HolesArrayReact" title="pyrid.data_structures.dynamic_array_util.HolesArrayReact"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.dynamic_array_util.HolesArrayReact</span></code></a>
<a class="reference internal" href="../Developer%20API/data_structures/dynamic_array_util.html#pyrid.data_structures.dynamic_array_util.DenseArrayReact" title="pyrid.data_structures.dynamic_array_util.DenseArrayReact"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.dynamic_array_util.DenseArrayReact</span></code></a>
<a class="reference internal" href="../Developer%20API/reactions/reactions_registry_util.html#pyrid.reactions.reactions_registry_util.Reaction" title="pyrid.reactions.reactions_registry_util.Reaction"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.reactions.reactions_registry_util.Reaction</span></code></a></p>
</div>
</details><p>The data structure we need to organize the reactions is a little bit
more complex than a simple dense, dynamic array or one with holes, as is
used to keep track of all the rigid body molecules and particles in the
system. Instead a combination of different dynamic arrays and a hash
table is used (Fig. <a class="reference external" href="#fig:DynamicArray_Reactions">1.10</a>). Let me
motivate this: Our data structure needs to be able to do four things as
efficient as possible:</p>
<ol class="arabic simple">
<li><p>Add reactions,</p></li>
<li><p>Delete single reactions,</p></li>
<li><p>Delete all reactions a certain particle participates in,</p></li>
<li><p>Return a random reaction from the list.</p></li>
</ol>
<p>We need to be able to delete a single reaction whenever this reaction is
not successful. We need to delete all reactions of a particle whenever a
reaction was successful because, in this case, the particle is no longer
available since it either got deleted or changed its type (except in the
case where the particle participates as an enzyme). We need to be able
to request a random reaction from the list because processing the
reactions in the order they occur in the list would introduce a
bias <a class="footnote-reference brackets" href="#id69" id="id64" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. Points 1. and 2. could be easily established with a simple
dynamic array. However, point 3 is a bit more complicated but can be
solved with a doubly free linked list embedded into a dynamic array with
holes. This doubly linked list connects all reactions of a particle. To
find the starting point (the head) of a linked list within the array for
a certain particle, we save the head in a hash table (python
dictionary). A doubly linked list is necessary because we need to be
able to delete a single reaction (of index k) from the linked list
(point 2). As such, we need to be able to reconnect the linked list’s
‘chain’. Therefore, we need to know the element in the linked list that
pointed to k (previous element) in addition to the element/reaction k
points to (next element). Another problem that needs to be solved is
that a reaction can be linked to at maximum two educts. Therefore, each
next and previous pointer needs to be 4-dimensional: We need one integer
for each educt to save the next (previous) reaction index and another
integer 0,1 to keep track of whether in the next (previous) reaction,
the particle is the first or the second educt, because this may change
from reaction to reaction! Since the dynamic array, the doubly linked
list is embedded, in has holes, picking a random reaction from the list
becomes another issue. This can, however, easily be solved by adding
another dynamic array (tightly packed), which keeps the indices of all
the reactions that are left in a tightly packed format. Picking a random
reaction is then as easy as drawing a uniformly distributed random
integer between 0 and n, where n is the length of the dense array.</p>
<figure class="align-default" id="fig-dynamicarray-reactions">
<a class="reference internal image-reference" href="../../_images/Reactions_DynamicArray1.png"><img alt="../../_images/Reactions_DynamicArray1.png" src="../../_images/Reactions_DynamicArray1.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 22 </span><span class="caption-text"><strong>Dynamic array for reactions.</strong> The dynamic array that keeps track
of all the reactions that need to be executed within a simulation
time step consists a free doubly linked list, a hash table (python
dictionary), one densely packed and one sparsely packed dynamic
array.</span><a class="headerlink" href="#fig-dynamicarray-reactions" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="polydispersity">
<h2>Polydispersity<a class="headerlink" href="#polydispersity" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/data_structures/h_grid_util.html#module-pyrid.data_structures.h_grid_util" title="pyrid.data_structures.h_grid_util"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.data_structures.h_grid_util</span></code></a>
<a class="reference internal" href="../Developer%20API/system/update_force.html#pyrid.system.update_force.update_force_append_reactions" title="pyrid.system.update_force.update_force_append_reactions"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.system.update_force.update_force_append_reactions</span></code></a></p>
</div>
</details><p>A problem that needs to be addresses, especially when using minimal
coarse-graining approaches with low granularity is polydispersity of
particle radii. One extreme example would, e.g., be a simulation where
proteins and synaptic vesicles are represented by single particles. In
this case classical linked cell list algorithms become highly
inefficient.</p>
<p>The computationally most expensive part in molecular dynamics
simulations is usually the calculation of the pairwise interaction
forces, because to calculate these, we need to determine the distance
between particles. When doing this in the most naive way, i.e. for each
particle i we iterate over all the other particles j in the system and
calculate the distance, the computation time will increase quadratic
with the number of particles in the system (<span class="math notranslate nohighlight">\(O(N^2)\)</span>). Even if we
take into account Newtons third law, this will decrease the number of
computations (<span class="math notranslate nohighlight">\(O(\frac{1}{2}N(N-1))\)</span>), but the computational
complexity still is quadratic in N. A straight forward method to
significantly improve the situation is the linked cell list approach
<span id="id65">[<a class="reference internal" href="../../References.html#id26" title="Michael P. Allen and Dominic J. Tildesley. Computer Simulation of Liquids. Oxford University Press, nov 2017. doi:10.1093/oso/9780198803195.001.0001.">3</a>]</span> (pp.195: 5.3.2 Cell structures and linked
lists) where the simulation box is divided into
<span class="math notranslate nohighlight">\(n \times n \times n\)</span> cells. The number of cells must be chosen
such that the side length of the cells in each dimension
<span class="math notranslate nohighlight">\(s = L/n\)</span>, where <span class="math notranslate nohighlight">\(L\)</span> is the simulation box length, is
greater than the maximum cutoff radius for the pairwise molecular
interactions (and in our case also the bimolecular reaction radii). This
will decrease the computational complexity to <span class="math notranslate nohighlight">\(O(14 N \rho s^3 )\)</span>,
where <span class="math notranslate nohighlight">\(\rho\)</span> is the molecule density (assuming a mostly
homogeneous distribution of molecules). Thereby, the computation time
increase rather linear with <span class="math notranslate nohighlight">\(N\)</span> instead of quadratic
(<span class="math notranslate nohighlight">\(N^2\)</span>).</p>
<p>However, one problem with this method is that it does not efficiently
handle polydisperse particle size distributions. This becomes a problem
when doing minimal coarse graining of proteins and other structures we
find in the cell such as vesicles. As mentioned above, n should be
chosen such that the cell length is greater than the maximum cutoff
radius. If we would like to simulate, e.g. proteins
(<span class="math notranslate nohighlight">\(r \approx 2-5 nm\)</span>) in the presence of synaptic vesicles
(<span class="math notranslate nohighlight">\(r \approx 20-30 nm\)</span>), the cells become way larger than necessary
from the perspective of the small proteins.</p>
<p>One way to approach this problem would be, to choose a small cell size
(e.g. based on the smallest cutoff radius) and just iterate not just
over the nearest neighbour cells but over as many cells such that the
cutoff radius of the larger proteins is covered. This approach has a big
disadvantages: Whereas for the smaller particles we actually reduce the
number of unnecessary distance calculations, we do not for the larger
particles as we iterate over all particles, also those, which are far
beyond the actual interaction radius. We can, however, still take
advantage of Newton’s 3rd law. For this, we only do the distance
calculation if the radius of particle i is larger than the radius of
particle j. If the radii are equal, we only do the calculation if index
i is smaller than index j.</p>
<p>A much better approach has been introduced by
<span id="id66">Ogarko and Luding [<a class="reference internal" href="../../References.html#id27" title="V. Ogarko and S. Luding. A fast multilevel algorithm for contact detection of arbitrarily polydisperse objects. Computer Physics Communications, 183(4):931–936, apr 2012. doi:10.1016/j.cpc.2011.12.019.">4</a>]</span> that makes use of a so called
hierarchical grid. This approach is the one I use in PyRID. In the
hierarchical grid approach, each particle is assigned to a different
cell grid depending on its cutoff radius, i.e. the grid consists of
different levels or hierarchies, each having a different cell size. This
has the downside of taking up more memory, however, it drastically
reduces the number of distance calculations we need to do for the larger
particles and also takes advantage of Newtons third law, enabling
polydisperse system simulations with almost no performance loss. The
algorithm for the distance checks works as follows
<span id="id67">[<a class="reference internal" href="../../References.html#id27" title="V. Ogarko and S. Luding. A fast multilevel algorithm for contact detection of arbitrarily polydisperse objects. Computer Physics Communications, 183(4):931–936, apr 2012. doi:10.1016/j.cpc.2011.12.019.">4</a>]</span>:</p>
<ol class="arabic simple">
<li><p>Iterate over all particles</p></li>
<li><p>Assign each particle to a cell on their respective level in the
hierarchical grid</p></li>
<li><p>Iterate over all particles once more</p></li>
<li><p>Do a distance check for the nearest neighbour cells on the level the
current particle sites in. This is done using the classical linked
cell list algorithm.</p></li>
<li><p>Afterwards, do a cross-level search. For this, distance checks are
only done on lower hierarchy levels, i.e. on levels with smaller
particle sizes than the current one. This way, we do not need to
double check the same particle pair (Newtons 3rd law). However, in
this step, we will have to iterate over potentially many empty cells.</p></li>
</ol>
</section>
<section id="simulation-loop">
<h2>Simulation loop<a class="headerlink" href="#simulation-loop" title="Permalink to this heading"></a></h2>
<p>At the beginning of each iteration, PyRID updates the position of all
particles. Next, PyRID determines the particle pair distances and based
on that calculates the forces and adds reactions to the reactions list.
Then, the reactions are performed. Thereby, new particles can enter the
system, either by a fusion or a fission reactions. In principle, the
inter-particle distances as well as the forces would need to be updated.
However, to save computation time this step is skipped. The only
exceptions are binding reactions, for which the force is calculated at
the time of reaction execution. Thereby, in the beginning of the next
iteration, the reaction products diffuse freely as they did not
experience any forces yet and the trajectory of particles that have been
in the system before also is not altered due to the presence of the new
molecules. Also, for molecules that where converted to a different type
the forces that are taken into account for the upcoming position update
are those that the molecule experienced before the type change. This is
of course an approximation but saves us from updating the particle
distances twice. For small integration time steps the error introduced
by this scheme should be small. Also, the product molecule placement
itself does already not resolve any collisions and other interactions
with nearby molecules. Therefore, a very similar error is introduced
anyway since resolving collisions would be unfeasible and take up too
much computation time. For fission reactions the error will be very
similar, no matter whether forces are updated or not. For fusion
reactions the the situation is slightly different because the educts
will leave behind an empty space that will be filled with new molecules.
But, also here, the error should be small for small time steps, which
need to be considered anyhow as soon as interactions are introduced. A
problem will always arise as soon as the system is dense and many
products enter the system at ones. In this case, the integration time
step should be decreased such that only a few products enter the system.</p>
<p>An alternative to the above approach would be to calculate all the
forces and add all the reactions to the reactions list at the beginning
of each iteration. Next we would update the molecule positions and only
then evaluate the reactions. This approach has the benefit that for the
product molecules, the forces will be evaluated directly after they have
been placed. However, because the products are only placed after the
molecule positions are updated, this results in a bias, especially for
bimolecular reactions. The first approach has the benefit that it does
not introduce any bias in the case where we do not consider
interactions. Therefore, this is the approach I took with PyRID. In
contrast, ReaDDy does update the neighbouring list for the molecules
twice per iteration. Once to evaluate the reactions and another time to
update the forces. However, in the worst case this could increase
computation time by a factor of two if the update of inter-molecular
distances is not optimized in some way. With the approach I took, forces
and reactions are evaluated in one loop over all particle pairs in the
neighbouring list and pair distances are calculated only once. One could
try to optimize the update of pair distances after the reactions have
been executed, since the pair distances between most particles stays the
same and we only need to consider those particles that left or entered
the system. However, this will be future work.</p>
</section>
<section id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this heading"></a></h2>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Implementation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text"><a class="reference internal" href="../Developer%20API/evaluation/evaluation_util.html#pyrid.evaluation.evaluation_util.Evaluation" title="pyrid.evaluation.evaluation_util.Evaluation"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyrid.evaluation.evaluation_util.Evaluation</span></code></a></p>
</div>
</details><p>For visualization, I have developed a blender addon for PyRID. In
addition, PyRID can visualize the different reactions using graphs.
Graph visualization in PyRID is build upon the pyvis library.</p>
<figure class="align-default" id="fig-blender-addon-gui">
<a class="reference internal image-reference" href="../../_images/blender_addon.jpg"><img alt="../../_images/blender_addon.jpg" src="../../_images/blender_addon.jpg" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23 </span><span class="caption-text"><strong>Visualization of molecule trajectories with PyRIDs Blender addon.</strong>
Left: Example visualization with 50.000 particles. Right: GUI of the
Blender addon.</span><a class="headerlink" href="#fig-blender-addon-gui" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-reactions-graph-vis">
<a class="reference internal image-reference" href="../../_images/ReactionsGraphs_Vis.png"><img alt="../../_images/ReactionsGraphs_Vis.png" src="../../_images/ReactionsGraphs_Vis.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 24 </span><span class="caption-text"><strong>Examples of different reaction graphs.</strong></span><a class="headerlink" href="#fig-reactions-graph-vis" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<aside class="footnote brackets" id="id68" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id63">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://web.archive.org/web/20220517145529/https://ourmachinery.com/post/data-structures-part-1-bulk-data/">https://web.archive.org/web/20220517145529/https://ourmachinery.com/post/data-structures-part-1-bulk-data/</a>
<a class="reference external" href="https://web.archive.org/web/20220314011542/https://ourmachinery.com/post/data-structures-part-2-indices/">https://web.archive.org/web/20220314011542/https://ourmachinery.com/post/data-structures-part-2-indices/</a>
<a class="reference external" href="https://web.archive.org/web/20220517134710/https://ourmachinery.com/post/data-structures-part-3-arrays-of-arrays/">https://web.archive.org/web/20220517134710/https://ourmachinery.com/post/data-structures-part-3-arrays-of-arrays/</a>
<a class="reference external" href="https://www.gamedeveloper.com/programming/data-structures-part-1-bulk-data">https://www.gamedeveloper.com/programming/data-structures-part-1-bulk-data</a></p>
</aside>
<aside class="footnote brackets" id="id69" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id64">2</a><span class="fn-bracket">]</span></span>
<p>Reactions of particles with a low index are added to the reaction
list first, because particle distances are evaluated in the order
particles occur in the corresponding list (which is, at least in the
beginning, in ascending order, when the indices of particles have not
yet been swapped around a lot). Thereby particle one would always
have a higher chance of having a successful reaction when competing
with other particles.</p>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="results.html" class="btn btn-neutral float-right" title="Results and validation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Moritz F P Becker.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>